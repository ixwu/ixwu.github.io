{"posts":[{"title":"如何快速开发一款小鹤双拼查询工具","content":"学生生涯结束，踏入社会，没有成绩、学分约束，没有老师、学校监督，完全凭个人兴趣、意志自学的技能，挑出三个你最有成就感的。 另外两个暂且不提，对于我来说，肯定会有小鹤双拼。 其实说「小鹤双拼」还不太准确，应该说「小鹤音形」。因为它不仅仅是一个双拼方案，还有双形方案。 双形即从每个字中提取首末两部分形态各异的组字单元，以区分同音字，组字单元即字根 比如「武」字，拆分是:一戈止，首字根是一(形码是 a，笔画中「横」对应 a)，末字根是止(形码是 v，zh 对应 v)，完整的小鹤音形码是: 「双拼+双形」，即wuav。小鹤的字根基本都取声母，不需要特别记忆。所以，学起来也不难，主要是要多练习，形成肌肉记忆。 基本坚持学习一个月就能掌握「小鹤音形」，此后四码上屏，打字如飞。我的意外收获是:借机学会了盲打，如虎添翼。 尽管我已熟练掌握小鹤音形，但是偶尔部分字还是会忘记编码。这时，我希望手边有一个工具能够辅助我快速查询编码。有爱好者制作了一款微信小程序，不过因为某些原因，该小程序需要看广告换积分来查询。pass。 另外还有一个网站可以查询编码。 如果不想折腾，这里已经可以打住了，iOS 端只需要将该网页「添加到主屏幕」即可，参见上篇文章。 但我喜欢折腾，下面，我将说说我是如何利用该网站的接口自己开发了一款小鹤编码查询工具。 先说说如何找接口。使用谷歌浏览器访问该网站，然后按 F12 进入开发者模式，执行查询时会发现多了一个叫 searchCode 的请求。 这是一个 POST 请求，请求 URL 是 http://www.xhup.club/Xhup/Search/searchCode。 请求头如下 其中，Host 告诉后台，浏览器想访问的 web 服务器的域名/IP 地址和端口号，这里是 www.xhup.club。Origin 告诉后台请求发起方是 http://react.xhup.club，所以后面假如我们想用 Python 模拟该请求必须带上该头部，否则后台判定该请求不合法，后面响应头部中有个: Access-Control-Allow-Origin: http://react.xhup.club，意思是只接受 http://react.xhup.club 发起的请求。 再来看看这个 Referer，跟 Origin 类似，我们是访问 http://react.xhup.club/search 后再发起的查询请求，所以这里记录的是上一个页面的 URL(协议+域名+查询参数) 即是 http://react.xhup.club/search。另外，还需要注意这个 User-Agent，当我们用 Python 调该接口时需要带上该头部以欺骗后台服务: 请求是浏览器发起的。 代码中请求头如下： headers = { 'Origin': 'http://react.xhup.club', 'Referer': 'http://react.xhup.club/search', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36', 'Host': 'www.xhup.club', 'Content-Type': 'application/x-www-form-urlencoded', 'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8', 'Accept': 'application/json, text/plain, */*', } 接下来是最关键的一步了。 我们执行查询时实际上是提交了一个表单，该表单包括所要查询的汉字与一个 sign。当表单上传编码格式为application/x-www-form-urlencoded，参数的格式（点击view source）如下 search_word=%E4%B8%AD&amp;sign=fa8d52dc60388d70b092c7f34db8f0c2 其中，汉字需要进行百分号转义。那么这里的 sign 是从哪来的呢? 通常是一个 md5 值。我们来看下相关 js 代码，打一些断点调试。 图中变量 e 为 key_xhup 的值，即 fjc_xhup，变量 r 为 search_word 的值，即所要查询的汉字，W() 不用管，姑且猜测为 md5 加密函数，这里对 fjc_xhup 与 search_word 合并后的字符串进行了加密作为 sign 的值。 在浏览器查询「中」的编码时，sign 值为: fa8d52dc60388d70b092c7f34db8f0c2。下面我们用 Python 的 md5 测试下。 In [1]: import hashlib In [2]: key_xhup = 'fjc_xhup' In [3]: search_word = '中' In [4]: sign = hashlib.md5((key_xhup + search_word).encode('utf-8')).hexdigest() ...: In [5]: print(sign) fa8d52dc60388d70b092c7f34db8f0c2 猜测正确。好了，剩下的事情就非常简单了。 我分别用 Pythonista 与苹果自带的快捷指令实现了该功能。其中，由于捷径的局限性，我设计为一次只能查询一个字的编码。 完整代码 捷径下载 ","link":"https://ixwu.github.io/howto-quickly-make-a-tool-for-xhup/"},{"title":"如何在iOS端优雅地bb？","content":"上篇博文介绍了如何利用 leanCloud 及 GitHub 搭建一个 「无赞无评论私人微博」并在 MacOS 端利用 uTools 发布内容，今天说说 iOS 端如何发布内容。 其实 uTools 是一款跨平台效率工具，Windows 与 Linux 端都可以使用。 在iOS 端，原作者 daibor 已经提供了一个「捷径」工具。如果不想再折腾了，其实已经够用了。 不过，我恰恰喜欢折腾。而且，苹果自带的「快捷指令」是面向大众的，操作简单，无需过多编程基础，就像搭积木一样组合功能。优点是上手简单，缺点是它不是一款专业的编程工具，它的简单在面向一些稍复杂点的需求时就不简单，比如调第三方接口的操作，显得异常繁琐。好在，iOS端还有一款专业级编程工具: Pythonista 入手 Pythonista 差不多一年了，平日只看看作者提供的一些案例(近百个):数据分析类、动画类、游戏类、UI 类、Widget 类等等，直接在上面编程次数并不多，主要是没啥需求，这下有了需求，正好派上用场。 代码如下： import requests import time import hashlib import console def main(): text = console.input_alert(u'这次想bb点啥？') if not text: print('No text input found.') return appId = ' ' # 填入 LeanCloud 中的 AppID masterKey = ' ' # 填入 LeanCloud 中的 MasterKey timestamp = int(round(time.time() * 1000)) ret = str(timestamp) + masterKey sign = hashlib.md5(ret.encode('utf-8')).hexdigest() data = {&quot;content&quot;: text} headers = { 'Content-Type': 'application/json', 'X-LC-Id': appId, 'X-LC-Sign': &quot;{},{},master&quot;.format(sign, timestamp) } url = 'https://{}.api.lncldglobal.com/1.1/classes/content'.format( appId[:8]) print(u'开始bb...') r = requests.post(url, json=data, headers=headers) print(u'bb中...') if r.status_code == 201: print(u'bb成功！') print(r.text) else: print(u'bb失败！') print(r.text) if __name__ == '__main__': main() 按如下操作将脚本执行快捷方式保存在主屏幕并执行，执行效果看倒数第二张动图。 ","link":"https://ixwu.github.io/howto-graciously-bb-in-ios/"},{"title":"如何在Mac上使用uTools优雅地bb？","content":"几天前看了少数派一篇教程「保卫表达：用后端 BaaS 快速搭建专属无点赞评论版微博——b言b语 」，顿时兴奋不已，这不正是我期盼已久的东西么。像新浪微博、之前 qq 空间里的说说以及现在的朋友圈，都有作者总结的如下问题。 会被点赞、评论机制刺激分泌多巴胺，导致莫名兴奋、并对此产生期待。这些情绪不仅干扰后续表达，也带来了回复的社交压力； 时间线+订阅的机制使我认为频繁发布无价值内容会打扰关注者； 为避免引战、被攻击以及各种原因需要进行严格的自我审查； 发布内容的路径长，经常被首页其他内容分散，浪费时间； 这些年，我逐渐在这些平台上&quot;销声匿迹&quot;，上述几个原因所占比重不可谓不大，毕竟我曾经也是文字表达欲极强的愤青一个，也被删过贴，也曾论过战，如今咬舌闭口，蒙眼塞耳，身困五斗稻粮谋，表达欲已然奄奄一息。所幸，照着作者教程搭完这个「私人微博」后，表达欲顿时重焕新生。 如果你也想有一个「无点赞评论私人微博」，至少需要做如下准备（具体可看作者所写教程，非常详尽，我就不叠床架屋了）。 注册 leanCloud (有国际版与国内版，当然选国际版了，再慢也选)并新建应用。创建一个class，命名为content，接着创建一个column（列），同样命名为content。说白了，content class 就是一张表，而 content column(列)就是这张表里的一个字段，后续「b 言 b 语」前端数据的呈现就是对这张表里数据的渲染，而客户端的操作就是对这张表进行增删改查。 接下来在设置中找到你的关键认证信息。 找一个地方把这几个关键信息存下来，后面都会用到。 注册 GitHub，并创建一个仓库，命名为: 用户名.github.io，比如用户名为 bb，那仓库命名为:bb.github.io，利用的是 GitHub 提供的 Pages 服务，如果嫌慢，可以使用国内的码云、coding 托管。不过，我更愿意用 GitHub，原因你懂的。 下载作者仓库中 index.html ，替换文件中的 AppID 与 AppKey，然后上传到你在 GitHub 上创建的仓库中。 做完以上三步，你的「私人微博」就搭建完成了，下面该考虑内容发布的事了。作者将平台命名为「b言b语」，索性我就将在该平台上发布内容称为bb了。Windows、iOS、安卓端都有现成的内容发布方案，唯独MacOS端没有。作为平日里的白嫖党，我也终于可以贡献一份力量了，于是有了下述方案。 内容发布其实就是调 leanCloud 接口在Content表中插入一条数据，常用的shell、Python都能实现，官方甚至有对应的SDK。不过在终端上总觉得不够优雅，我想整一个大众都能用的。思来想去，我想到了久未打开的uTools。用过Mac的，必然知道Splotlight，再进一步，必然知道传说中的Alfred。而uTools就是一款国人开发的类Alfred软件，上面有大量的生产力相关的插件工具，而且是免费的哦。 uTools上有一款插件叫：快捷命令。你可以用熟悉的编程语言编写脚本，然后通过uTools调用。 进入该插件后，可以新建一条命令。如下图所示，使用shell中curl命令调leanCloud接口发布信息。 下面是Python版 #!/usr/local/bin/python3 # _*_ coding: utf-8 _*_ import urllib3 import json urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) data = {&quot;content&quot;: &quot;{{subinput}}&quot;} headers = { 'Content-Type': 'application/json', 'X-LC-Id': '', # 填入AppID 'X-LC-Key': ',master' # 逗号前填入masterKey } url = 'https://AppID前八位.api.lncldglobal.com/1.1/classes/content' http = urllib3.PoolManager(timeout = 3) r = http.request('POST', url, body=json.dumps(data), headers = headers) if str(r.status) == &quot;201&quot;: print('success!') print(json.loads(r.data.decode('utf-8'))) else: print('something is wrong!') 具体脚本内容及后续优化可在仓库中找到 从上述描述可知，要发布的内容是通过uTools的变量传递到脚本中的。我只推荐其中两个变量，一个是{{ClipText}}即剪贴板中的文本，另一个是{{subinput}}，指的是子输入框文本，也是我最终采用的变量，可能不如剪贴板好理解，所以我做了一个动图。 ok，让我们一起bb吧。 ","link":"https://ixwu.github.io/howto-graciously-bb-in-mac/"},{"title":"如何在Notion中计算某日属于当年第几周？","content":"玩Notion已近一年，今天才知道怎么用最简单的方式轻松计算某日属于当年第几周。不过，也怪不得我啊，官方示例根本就没有，各个notion达人也没见哪一位提到这一点，下面说说我是怎么误打误撞发现的吧。 源起 几天前，看到Linmi大佬的视频号在推一个「2020年习惯打卡」的模板，感觉不错，就去Notion中文社区找到了这个模板。一看，确实不错，美中不足的是周数是由人工填写的（对于直接使用该模板的人没啥影响，但对于制作者Melody来说就有些痛苦啦）。 本周视图是根据「周数」字段的值过滤（Filter）出来的，而「周数」字段值并非公式（Formula）计算得出。 也就是说，每新增一条「习惯打卡」就要手动填写这个「周数」字段值。下图中 ∑ 图标字段代表是由公式（Formula）计算得出。 Notion中公式有不少，可惜就是没有这个计算周数的。 当然，Notion支持csv导入，先在excel中用相应公式处理下，转换为csv文件，再导入Notion也是可行的。不过，我更喜欢用官方原生方法来处理。几经折腾，最终还是找到了最优方法。折腾过程就不多啰嗦了，各种看官时间宝贵，我还是直接说答案吧。 formatDate(prop(&quot;Date&quot;), &quot;W&quot;) 先来看下formatDate()这个公式的官方示例。 # 语法 formatDate(date, text) # 示例 formatDate(now(), &quot;MMMM D YYYY, HH:mm&quot;) == March 30 2010, 12:00 formatDate(now(), &quot;YYYY/MM/DD, HH:mm&quot;) == 2010/03/30, 12:00 formatDate(now(), &quot;MM/DD/YYYY, HH:mm&quot;) == 03/30/2010, 12:00 formatDate(now(), &quot;HH:mm A&quot;) == 12:00 PM formatDate(now(), &quot;M/D/YY&quot;) == 3/30/10 就是用格式化（FORMAT）日期字符串格式化输出日期（date），很多编程语言都有这种用法。 比如shell中Date命令 $ date +&quot;%Y/%m/%d %H-%M-%S&quot; 2020/03/28 18-51-24 python中datetime模块 &gt;&gt;&gt; a = datetime.datetime.now() &gt;&gt;&gt; a.strftime(&quot;%Y/%m/%d&quot;) '2020/03/28' shell与python中计算当日属于第几周的格式（FORMAT）如下 %W 一年中的第几周，以周一为每星期第一天(00-53) %V ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53) %U 一年中的第几周，以周日为每星期第一天(00-53) Notion中对应FORMAT如下。 # 一年中第几周，以周一(大写W)为每星期第一天（1-53） formatDate(Date, &quot;W&quot;) # 一年中第几周，以周日（小写w）为每星期第一天（1-53） formatDate(Date, &quot;w&quot;) 比如，2019年12月29日是周日，按照第一种方式的话，计算出来就是2019年第52周，用第二种方式计算出来是2020年第1周。显然，第一种方式更符合我们的要求。 趁热打铁，我又试出了其他几个Notion未公布的FORMAT。 # 毫秒时间戳（x小写） formatDate(Date, &quot;x&quot;) # 秒时间戳（x大写） formatDate(Date, &quot;X&quot;) # 时区（CST），z小写 formatDate(Date, &quot;z&quot;) # 时区（+08:00），z大写 formatDate(Date, &quot;z&quot;) # 长格式时间（3/28/2020），l小写 formatDate(Date, &quot;l&quot;) # 长格式时间（03/28/2020），L大写 formatDate(Date, &quot;L&quot;) # 周几（周日的话输出0，其它为1-6），e小写 formatDate(Date, &quot;e&quot;) # 周几（周日的话输出7，其它为1-6），e大写 formatDate(Date, &quot;E&quot;) 后记 极限测试发现该方法有问题：2000年12月31日是星期日，该日应属于当年第53周，不过上述公式计算出来的结果是：第52周。2000年1月1日属于第一周，上述计算出来的结果是：第52周。 所以，各位如果有计算某日属于第几周的需求可以用我这个公式，虽然复杂了点（使用公式前把&quot;Date&quot;字段替换为要计算周数的日期字段）。 if(day(dateAdd(fromTimestamp(-115200000), year(prop(&quot;Date&quot;)) - year(fromTimestamp(-115200000)), &quot;years&quot;)) != 0 and ceil(dateBetween(prop(&quot;Date&quot;), dateSubtract(dateAdd(fromTimestamp(-115200000), year(prop(&quot;Date&quot;)) - year(fromTimestamp(-115200000)) - 1, &quot;years&quot;), day(dateAdd(fromTimestamp(-115200000), year(prop(&quot;Date&quot;)) - year(fromTimestamp(-115200000)) - 1, &quot;years&quot;)), &quot;days&quot;), &quot;days&quot;) / 7) == 53, 1, ceil(dateBetween(prop(&quot;Date&quot;), dateSubtract(dateAdd(fromTimestamp(-115200000), year(prop(&quot;Date&quot;)) - year(fromTimestamp(-115200000)) - 1, &quot;years&quot;), day(dateAdd(fromTimestamp(-115200000), year(prop(&quot;Date&quot;)) - year(fromTimestamp(-115200000)) - 1, &quot;years&quot;)), &quot;days&quot;), &quot;days&quot;) / 7)) 参考 2020年习惯打卡原版 2020年习惯打卡中文版 ","link":"https://ixwu.github.io/howto-get-the-week-of-year-in-notion/"},{"title":"利用kubeadm部署kubernetes1.17.2","content":"准备工作 在京东云买了三台云主机 主机名 角色 内网ip CPU核数 内存 磁盘 操作系统 内核 JD1 master 10.0.0.3 2 4GB 40GB CentOS 7.3 3.10.0 JD2 worker 10.0.0.4 2 4GB 40GB CentOS 7.3 3.10.0 JD3 worker 10.0.0.5 2 4GB 40GB CentOS 7.3 3.10.0 配置kubernetes yum源 京东云自带的yum源无kubernetes，需要添加阿里云的源 vim /etc/yum.repos.d/kubernetes.repo [kubernetes] name=kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ gpgcheck=0 enable=1 yum clean all &amp;&amp; yum makecache 测试 [root@JD1 yum.repos.d]# yum list | grep kubeadm kubeadm.x86_64 1.17.2-0 kubernetes 安装 Docker 三台机器上都需要安装 [root@JD1 ~]# yum install docker -y [root@JD1 ~]# systemctl start docker [root@JD1 ~]# systemctl enable docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. [root@JD1 yum.repos.d]# docker version Client: Version: 1.13.1 API version: 1.26 Package version: docker-1.13.1-103.git7f2769b.el7.centos.x86_64 Go version: go1.10.3 Git commit: 7f2769b/1.13.1 Built: Sun Sep 15 14:06:47 2019 OS/Arch: linux/amd64 Server: Version: 1.13.1 API version: 1.26 (minimum version 1.12) Package version: docker-1.13.1-103.git7f2769b.el7.centos.x86_64 Go version: go1.10.3 Git commit: 7f2769b/1.13.1 Built: Sun Sep 15 14:06:47 2019 OS/Arch: linux/amd64 Experimental: false 安装 kubeadm 三台机器上都需要安装 yum install kubeadm -y ...... Installed: kubeadm.x86_64 0:1.17.2-0 Dependency Installed: conntrack-tools.x86_64 0:1.4.4-5.el7_7.2 cri-tools.x86_64 0:1.13.0-0 kubectl.x86_64 0:1.17.2-0 kubelet.x86_64 0:1.17.2-0 kubernetes-cni.x86_64 0:0.7.5-0 libnetfilter_cthelper.x86_64 0:1.0.0-10.el7_7.1 libnetfilter_cttimeout.x86_64 0:1.0.0-6.el7_7.1 libnetfilter_queue.x86_64 0:1.0.2-2.el7_2 socat.x86_64 0:1.7.3.2-2.el7 kubelet、kubectl、kubenetes-cni也跟着一起安装好了 配置kubelet开机启动 systemctl enable kubelet 部署 Master节点 以jd1作为master节点，另外两台为worker节点 方法一：命令行 kubeadm init --kubernetes-version=v1.17.2 \\ --pod-network-cidr=10.244.0.0/16 \\ --service-cidr=10.96.0.0/12 \\ --apiserver-advertise-address=10.0.0.3 方法二：配置文件(推荐，本次也采用该方式) 使用kubeadm配置文件，由于本次下载的kubeadm版本过高，安装低版本k8s集群时报错，索性就安装最新版本的k8s了。 # 生成配置文件 kubeadm config print init-defaults ClusterConfiguration &gt;kubeadm.yaml 修改默认镜像仓库，由于大家都懂得的原因，谷歌默认容器镜像地址k8s.gcr.io无法访问，修改为registry.cn-hangzhou.aliyuncs.com/google_containers vim kubeadm.yaml #修改 imageRepository: k8s.gcr.io #改为 imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers #修改 advertiseAddress: 1.2.3.4 #改为 advertiseAddress: 10.0.0.3 最终版本 apiVersion: kubeadm.k8s.io/v1beta2 kind: InitConfiguration localAPIEndpoint: advertiseAddress: 10.0.0.3 bindPort: 6443 nodeRegistration: criSocket: /var/run/dockershim.sock name: jd1 taints: - effect: NoSchedule key: node-role.kubernetes.io/master --- apiServer: timeoutForControlPlane: 4m0s apiVersion: kubeadm.k8s.io/v1beta2 certificatesDir: /etc/kubernetes/pki clusterName: kubernetes controllerManager: {} dns: type: CoreDNS etcd: local: dataDir: /var/lib/etcd imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers kind: ClusterConfiguration kubernetesVersion: v1.17.2 networking: dnsDomain: cluster.local podSubnet: 10.244.0.0/16 serviceSubnet: 10.96.0.0/12 scheduler: {} 查看kubeadm config所需的镜像，更多kubeadm config命令 [root@JD1 ~]# kubeadm config images list --config kubeadm.yaml W0126 20:54:01.849570 9619 validation.go:28] Cannot validate kube-proxy config - no validator is available W0126 20:54:01.849607 9619 validation.go:28] Cannot validate kubelet config - no validator is available registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.17.2 registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:v1.17.2 registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:v1.17.2 registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.17.2 registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1 registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.4.3-0 registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.5 提前下载好这些镜像 [root@JD1 ~]# kubeadm config images pull --config kubeadm.yaml W0126 19:44:46.987395 27714 validation.go:28] Cannot validate kube-proxy config - no validator is available W0126 19:44:46.987429 27714 validation.go:28] Cannot validate kubelet config - no validator is available [config/images] Pulled registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.17.2 [config/images] Pulled registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:v1.17.2 [config/images] Pulled registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:v1.17.2 [config/images] Pulled registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.17.2 [config/images] Pulled registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1 [config/images] Pulled registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.4.3-0 [config/images] Pulled registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.5 初始化master节点 [root@JD1 ~]# kubeadm init --config kubeadm.yaml W0126 20:57:30.795523 10460 validation.go:28] Cannot validate kube-proxy config - no validator is available W0126 20:57:30.795570 10460 validation.go:28] Cannot validate kubelet config - no validator is available [init] Using Kubernetes version: v1.17.2 [preflight] Running pre-flight checks [preflight] Pulling images required for setting up a Kubernetes cluster [preflight] This might take a minute or two, depending on the speed of your internet connection [preflight] You can also perform this action in beforehand using 'kubeadm config images pull' [kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot; [kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot; [kubelet-start] Starting the kubelet [certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot; [certs] Generating &quot;ca&quot; certificate and key [certs] Generating &quot;apiserver&quot; certificate and key [certs] apiserver serving cert is signed for DNS names [jd1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.0.0.3] [certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key [certs] Generating &quot;front-proxy-ca&quot; certificate and key [certs] Generating &quot;front-proxy-client&quot; certificate and key [certs] Generating &quot;etcd/ca&quot; certificate and key [certs] Generating &quot;etcd/server&quot; certificate and key [certs] etcd/server serving cert is signed for DNS names [jd1 localhost] and IPs [10.0.0.3 127.0.0.1 ::1] [certs] Generating &quot;etcd/peer&quot; certificate and key [certs] etcd/peer serving cert is signed for DNS names [jd1 localhost] and IPs [10.0.0.3 127.0.0.1 ::1] [certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key [certs] Generating &quot;apiserver-etcd-client&quot; certificate and key [certs] Generating &quot;sa&quot; key and public key [kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot; [kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file [kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file [kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file [kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file [control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot; [control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot; [control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot; W0126 20:57:34.329698 10460 manifests.go:214] the default kube-apiserver authorization-mode is &quot;Node,RBAC&quot;; using &quot;Node,RBAC&quot; [control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot; W0126 20:57:34.330430 10460 manifests.go:214] the default kube-apiserver authorization-mode is &quot;Node,RBAC&quot;; using &quot;Node,RBAC&quot; [etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot; [wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s [apiclient] All control plane components are healthy after 15.001757 seconds [upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace [kubelet] Creating a ConfigMap &quot;kubelet-config-1.17&quot; in namespace kube-system with the configuration for the kubelets in the cluster [upload-certs] Skipping phase. Please see --upload-certs [mark-control-plane] Marking the node jd1 as control-plane by adding the label &quot;node-role.kubernetes.io/master=''&quot; [mark-control-plane] Marking the node jd1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule] [bootstrap-token] Using token: abcdef.0123456789abcdef [bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles [bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials [bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token [bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster [bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace [kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key [addons] Applied essential addon: CoreDNS [addons] Applied essential addon: kube-proxy Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config You should now deploy a pod network to the cluster. Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ Then you can join any number of worker nodes by running the following on each as root: kubeadm join 10.0.0.3:6443 --token abcdef.0123456789abcdef \\ --discovery-token-ca-cert-hash sha256:2957de566c5bcf9bee9fb2211d1bf0d9cb85eeefb2c5eed35443390728e45957 配置常规用户 [root@JD1 ~]# mkdir -p $HOME/.kube [root@JD1 ~]# cp -i /etc/kubernetes/admin.conf $HOME/.kube/config [root@JD1 ~]# chown $(id -u):$(id -g) $HOME/.kube/config 查看集群状态 [root@JD1 ~]# kubectl get cs NAME STATUS MESSAGE ERROR scheduler Healthy ok controller-manager Healthy ok etcd-0 Healthy {&quot;health&quot;:&quot;true&quot;} 安装Pod Network 接下来安装flannel network add-on [root@JD1 ~]# mkdir -p ~/k8s/ [root@JD1 ~]# cd ~/k8s [root@JD1 k8s]# curl -O https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 14416 100 14416 0 0 6772 0 0:00:02 0:00:02 --:--:-- 6774 [root@JD1 k8s]# ls kube-flannel.yml [root@JD1 k8s]# kubectl apply -f kube-flannel.yml podsecuritypolicy.policy/psp.flannel.unprivileged created clusterrole.rbac.authorization.k8s.io/flannel created clusterrolebinding.rbac.authorization.k8s.io/flannel created serviceaccount/flannel created configmap/kube-flannel-cfg created daemonset.apps/kube-flannel-ds-amd64 created daemonset.apps/kube-flannel-ds-arm64 created daemonset.apps/kube-flannel-ds-arm created daemonset.apps/kube-flannel-ds-ppc64le created daemonset.apps/kube-flannel-ds-s390x created 添加worker节点至集群 在另外两台机器上执行如下命令即可 [root@JD3 ~]# kubeadm join 10.0.0.3:6443 --token abcdef.0123456789abcdef \\ --discovery-token-ca-cert-hash sha256:2957de566c5bcf9bee9fb2211d1bf0d9cb85eeefb2c5eed35443390728e45957 W0126 21:15:58.144981 6559 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set. [preflight] Running pre-flight checks [preflight] Reading configuration from the cluster... [preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml' [kubelet-start] Downloading configuration for the kubelet from the &quot;kubelet-config-1.17&quot; ConfigMap in the kube-system namespace [kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot; [kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot; [kubelet-start] Starting the kubelet [kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap... This node has joined the cluster: * Certificate signing request was sent to apiserver and a response was received. * The Kubelet was informed of the new secure connection details. Run 'kubectl get nodes' on the control-plane to see this node join the cluster. 查看节点信息 在master节点查看 [root@JD1 ~]# kubectl get nodes NAME STATUS ROLES AGE VERSION jd1 Ready master 19m v1.17.2 jd2 Ready &lt;none&gt; 9m55s v1.17.2 jd3 Ready &lt;none&gt; 105s v1.17.2 查看集群状态信息 [root@JD1 ~]# kubectl cluster-info Kubernetes master is running at https://10.0.0.3:6443 KubeDNS is running at https://10.0.0.3:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'. 查看k8s集群server端与client端的版本信息 [root@JD1 ~]# kubectl version --short=true Client Version: v1.17.2 Server Version: v1.17.2 拷贝admin.conf到worker节点 worker节点运行kubectl命令报错 The connection to the server localhost:8080 was refused - did you specify the right host or port? kubectl命令需要使用kubernetes-admin来运行，将主节点中的/etc/kubernetes/admin.conf文件拷贝到worker节点相同目录下 [root@JD2 ~]# scp root@jd1:/etc/kubernetes/admin.conf /etc/kubernetes/ 然后执行 [root@JD2 ~]# mkdir -p $HOME/.kube [root@JD2 ~]# cp -i /etc/kubernetes/admin.conf $HOME/.kube/config [root@JD2 ~]# chown $(id -u):$(id -g) $HOME/.kube/config jd3主机也作同样操作，再次执行kubectl命令查看 # 检查nodes [root@JD2 ~]# kubectl get nodes NAME STATUS ROLES AGE VERSION jd1 Ready master 63m v1.17.2 jd2 Ready &lt;none&gt; 52m v1.17.2 jd3 Ready &lt;none&gt; 52m v1.17.2 # 检查pods [root@JD2 ~]# kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE kube-system coredns-7f9c544f75-hc954 1/1 Running 0 64m kube-system coredns-7f9c544f75-nlrkx 1/1 Running 0 64m kube-system etcd-jd1 1/1 Running 0 64m kube-system kube-apiserver-jd1 1/1 Running 0 64m kube-system kube-controller-manager-jd1 1/1 Running 0 64m kube-system kube-flannel-ds-amd64-27b72 1/1 Running 0 57m kube-system kube-flannel-ds-amd64-27l7c 1/1 Running 0 53m kube-system kube-flannel-ds-amd64-7bg5p 1/1 Running 0 53m kube-system kube-proxy-44698 1/1 Running 0 53m kube-system kube-proxy-flx2c 1/1 Running 0 64m kube-system kube-proxy-kk2nd 1/1 Running 0 53m kube-system kube-scheduler-jd1 1/1 Running 0 64m kubernetes-dashboard dashboard-metrics-scraper-7b64584c5c-jwmhv 1/1 Running 0 47m kubernetes-dashboard kubernetes-dashboard-566f567dc7-ktdpf 1/1 Running 0 47m ","link":"https://ixwu.github.io/config-k8s-1.17.2-with-kubeadm/"},{"title":"利用Jupyter Notebook打造go及python交互式编程环境","content":"先说说Jupyter Notebook Jupyter Notebook既是一款笔记应用，又是一款交互式编程工具，号称支持运行40种编程语言。之前受李笑来在GitHub上的项目--自学是一门艺术影响，下过一次，玩了玩，不过当时鲁钝，并未识得其好。近来，突然醒悟，这真是一款学习编程的好工具。 比如python。单纯用命令行python解释器的话，无法实现命令补全，用IPython的话，虽然能实现命令补全，但是笔记又得借助其他软件，二者是割裂的，下次想修改那段代码，想看效果，你又得拷到IPython中。 那么IDE怎么样呢？确实能实现实时查看代码执行效果，可以利用注释做笔记，但是当你的代码量变多了，而你只是想运行其中一部分代码的时候，你是注释其他代码还是另起一个新文件呢？而且IDE一般都很臃肿，打开速度都挺慢。综合以上，关于代码的学习笔记，我都选择用Jupyter。 以上是我近期使用Jupyter得来的一点浅识。看看大佬怎么说的。 从2017年开始，已有大量的北美顶尖计算机课程，开始完全使用Jupyter Notebook作为工具。比如李⻜⻜的CS231N《计算机视觉与神经网络》课程，在16年时作业还是命令行Python的形式，但是17年的作业就全部在Jupyter Notebook上完成了。再如UC Berkeley的《数据科学基础》课程，从17年起，所有作业也全部用 Jupyter Notebook完成。 而Jupyter Notebook 在工业界的影响力更甚。在Facebook，虽然大规模的后台开发仍然借助于功能⻬全的IDE，但是几乎所有的中小型程序，比如内部的一些线下分析软件，机器学习模块的训练都是借助于Jupyter Notebook完成的。据我了解，在别的硅谷一线大厂，例如Google的AI Research部⻔Google Brain，也是清一色地全部使用Jupyter Notebook，虽然用的是他们自己的改进定制版，叫 Google Colab。 以上两段文字引自Fackbook资深工程师景霄在极客时间上的课程《Python核心技术与实战--02讲JupyterNotebook为什么是现代Python的必学技术》。下面这个图片中的代码同样引自该课程。 总之，知道Jupyter Notebook真的很方便很实用就行了。下面总结下如何在Jupyter Notebook上安装python内核与go内核。如下操作均是在macOS系统上操作完成。 python交互式编程 Jupyter本来就是因为python而诞生的，所以搞python内核很容易。如果你之前装了IPython，直接下载jupyter就行了。 # 安装python3 $ brew install python3 # 安装pip $ curl https://bootstrap.pypa.io/get-pip.py | python3 # 安装ipython(如果出现权限问题，可以试试pip3 install ipython --user) $ pip3 install ipython # 安装jupyter $ pip3 install jupyter # 启动jupyter $ jupyter notebook 执行启动命令后，会自动打开你的浏览器，本地链接为：http://localhost:8888/tree，你也可以在启动时使用 --port指定端口 使用起来很简单，就不做过多介绍了。文件后缀为ipynb，你可以使用git管理你的笔记，上传到远程仓库GitHub上，可以直接渲染该文件。 golang交互式编程 go内核的安装稍微麻烦点。 # 安装go $ brew install go $ go version go version go1.12.4 darwin/amd64 # 安装Jupyter Notebook $ pip3 install jupyter # 安装ZeroMQ $ brew install zmq # 我这里遇到的坑是创建软链时提示/usr/local/lib不可写，原来该目录属主是root，改成个人账户就行了 # 假如你用Mac或Linux把属主改成当前用户就行了 $ sudo chown -R roy:admin /usr/local/lib # 然后按照之前的提示重新链接文件 $ brew link zeromq # 配置环境变量，我用的zsh，修改.zshrc; bash的话修改.bashrc $ vim ~/.zshrc export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig export GOPATH=/Users/roy/go # 使配置生效 $ source ~/.zshrc # 利用pkg-config获取libzmq所有编译相关的信息 $ pkg-config --cflags libzmq # 安装go内核(利用go get从github上下载gophernotes) $ go get -u github.com/gopherdata/gophernotes $ mkdir -p ~/Library/Jupyter/kernels/gophernotes $ cp $GOPATH/src/github.com/gopherdata/gophernotes/kernel/* ~/Library/Jupyter/kernels/gophernotes # 将gophernotes加入PATH $ vim ~/.zshrc export PATH=$GOPATH/bin:$PATH # 使配置生效 $ source ~/.zshrc # 启动jupyter $ jupyter notebook 好了，你可以在Jupter上愉快地玩go了。以上操作基于Mac，其他操作系统的安装可以参考官方文档 ","link":"https://ixwu.github.io/howto-config-go-python-kernel-for-jupyter-notebook/"},{"title":"读史杂草-201902","content":"授人以柄 前秦苻坚统一了大半个中国，独东南一隅（即东晋）未沾王化。他如传道士一般，欲传“王道”之福音于“中国”每一寸土地，遂不顾群臣反对，亲自带兵征讨，并封主战派姚苌为龙骧将军。 苻坚对姚苌说：“朕曾以龙骧之位，建功立业。从未轻易授人，爱卿切莫辜负朕的期望。”左将军窦冲曰：“王者无戏言，此不祥之诏也！”坚默然。 后来，姚苌杀苻坚，建立后秦。 “企鹅”官员 BBC同腾讯视频联手打造的纪录片《王朝》，有一集专门讲帝企鹅的生存。 南极乃极寒之地，却阻挡不了企鹅们繁衍后代，母企鹅诞下企鹅蛋后，由公企鹅负责孵化，来不及坐“月子”的她们则踏上出海觅食的征程。如果走运找到食物而又万幸活着回来并找到竟然没有冻死饿死的公企鹅与企鹅宝宝的话，她会呕吐食物让企鹅宝宝从嘴中取食。然后，母企鹅留下照顾企鹅宝宝，公企鹅则会代替“妻子”踏上险象环生的觅食之旅。 人类历史上也有惊人相似的一幕：晋烈宗太元十年。春，正月，秦王坚朝飨群臣。时长安饥，人相食，诸将归，吐肉以饲妻子。秋，八月，后秦王姚苌杀前秦王坚。 小人姚苌 后秦主姚苌之所做所为，足见小人之可怕可悲。其初随兄长姚襄与前秦战，大败，襄死，苌降。苻眉欲斩之，苻坚制止。 苻坚继位后，重用姚苌，淝水之战时更提拔其为龙骧将军，荣宠可谓极矣。 淝水一役次年，前秦国力衰颓，姚苌乘乱自立，建立后秦。不久，擒杀前主子苻坚，这还没完，又掘墓鞭尸。 可笑的是，与苻登战时，他屡战屡败，见苻登军中有苻坚神位，谓其得苻坚神助，遂于军中立苻坚像。暗中向苻坚祈祷，言己不过为兄襄复仇，陛下既然授予龙骧之位，岂敢违之。今为陛下立像，陛下莫要追究臣之过错啦。 与登战，依旧不利，且每夜看到苻坚像就吓一跳，又惹得军中人心惶惶，索性斩像首送给苻登。 不以为耻 后秦王苌某次与群臣宴，酒酣之时对大臣们说：“诸位爱卿曾与朕北面事秦，今我为君，诸位为臣，难道不觉得羞耻吗？”赵迁曰：“天不耻以陛下为子，臣等何耻为臣！”苌大笑。 帝王教训 古代帝王皆爱总结成败教训，姚苌也不例外。 后秦与前秦苻登僵持甚久，诸将抱怨姚苌太过持重，使得苻登屡屡逃生。苌笑曰：“吾不如亡兄有四：身长八尺五寸、臂垂过膝，人望而畏之，一也；将十万之众，与天下争衡，望麾而进，前无横隈，二也；温古知今，讲论道艺，收罗英隽，三也；董帅兄众，上下咸悦，人尽死力，四也。所以得建立功业、驱策群贤者，正望算略中有片长耳。”群臣咸称万岁。 好尴尬啊 魏王珪与燕太子丹临河作战，忽暴风起，漂燕军数十艘船至对岸，魏军尽获其甲士三百余人，皆释而遣之。 有一位喜剧演员，口头禅是：好尴尬啊。我猜，燕军心中皆作此念。 “傻”皇帝 晋朝出了两个著名的“傻”皇帝。一个是西晋的晋惠帝，一个是东晋的孝武帝。 前者因“何不食肉糜”被嘲笑了上千年，我独耿耿于怀于嵇康后代为其舍身。后者因一句戏言（对爱妾张贵人开玩笑说，你这个年龄就该废了，我更喜欢年龄小的）被爱妾联合宫女用被子闷死，真可谓“千古一帝”。 ","link":"https://ixwu.github.io/history-cards-201902/"},{"title":"读史杂草-201901","content":"1.如此朋友 东晋元帝时，朝廷偏安江东。当时，王敦外握兵权，王导内掌朝政，琅琊王氏一族皆身居要职，时谚曰：王与马，共天下。后王敦造反，有人劝晋元帝杀尽王氏。王导遂率宗族二十余人，每日凌晨于台阁处待罪。 这日，周顗（yǐ，字伯仁）入朝，导呼之，顗直入不顾，见帝，大谈导之忠诚，极力营救，帝纳之。出，导犹在，又呼之，顗不与言，归家又上表，言导无罪。王导皆不知也，心甚恨之。 王敦得胜，欲杀周顗，问王导意见，连问三次，皆不答，于是周顗被杀。导后见顗所上表皆为救己，流涕曰：“吾虽不杀伯仁，伯仁由我而死，幽冥之中，负此良友”。 2.如此君王 《功夫》中冯小刚饰演的黑帮老大被斧头帮老大砍死前说的台词是：“慢着，慢着，你还记得吗？我还请你吃过饭。” 东晋前期，北方前赵后赵连连交战，最终前赵之主刘曜兵败被俘，面对后赵之主石勒，这位昔日并肩作战的同僚，曜深情地说道：“石王，颇忆重门之盟否？”结局可想而知。 3.如此同僚 桓温晚年效仿伊、霍，行废立之事，诛异己之人，权侵朝野，人人自危。谢安见之遥拜，温惊曰：“安石，卿何事乃尔？”安曰：“未有君拜于前，臣揖于后。” 温与郗超交好，于是朝中皆畏事之，谢安曾与王坦之拜访他，天黑也未得见，坦之欲去，安曰：“独不能为性命忍须臾邪？”后桓温至死未能篡位，皆赖王谢二家。 4.如此君臣 东晋十六国时期，后赵石勒靠汉人张宾称霸北方，不久后赵被灭，前秦苻坚靠汉人王猛统一北方，可惜这两位顶级谋士都死得早。 张宾死时，石勒大哭：“天不欲成吾事邪？何夺吾右侯之早也！”王猛死时，苻坚恸哭：“天不欲使吾平壹六合耶？何夺吾景略之速也？” 另外，王猛临死，劝坚莫图东晋，苻坚不听，于是贡献了“草木皆兵、风声鹤唳”等成语。 擅长意淫的“小说家”在《续三国演义》将张宾描绘成蜀国大将张飞的孙子，说其尽得孔明姜维真传，石勒成了赵云的孙子，他们“乱华”不过是为汉室报仇。而本来就打着刘氏旗号的刘渊被杜撰为刘备之孙，好吧，汉人的面子都在小说里被挣回来了。 5.如此父子 中国人的孝顺有很多种，有的很别样。东晋简文帝时期，桓温把持朝政，一度欲“取而代之”，死后其党未遭清算，比如郗超，竟得善终。其父郗愔忠于王室，超一直瞒着父亲与桓氏为党。临终前，他给了门生一箱书信，说，我死后，家父若太过悲痛，可呈此箱，否则立即焚之。后来，超死，其父果然哀惋成疾，门生呈箱，皆与桓温密谋奸计。愔看后，大怒曰：这小子死得太晚了。再也不为之痛哭了。 ","link":"https://ixwu.github.io/history-cards-201901/"},{"title":"我是怎么用两个多小时掌握盲打的","content":"人人都能学会盲打 不瞒各位，在2017年之前，我也是“二指禅”。打字时，两只眼睛不时瞄下键盘，两只手的食指和中指还得在键盘上找半天。 我也曾以为，盲打是“熟能生巧”的结果，唯有经年累月的修炼才能习得；初中时，我曾对着计算机教材上的键位图学习指法，但是十几分钟后，便觉得索然无味，书扔到一边，仰天长叹，好难啊，看来我这辈子是不可能学会盲打的。 我也曾以为，学习是靠毅力来维持，没有毅力，没有坚持，任何事也干不成。但后来，看了大量与“学习”相关的文章与视频，对自己的失败经历多次反省后，才知道这些想法都大错特错，一直以来阻碍我进步的源头就是这些错误的思想。 所以，2017年，我决定推倒重来，于是我开始学习盲打。最终，只用了两个多小时就掌握了这个我曾以为遥不可及的技能。其实，学习盲打一点也不难，关键是学习方法，方法选对了，人人都能快速学会。比如，我女朋友的盲打就是我教会的。 最好的学习方法 首先澄清一点，不是说毅力无用，许多人都靠坚持和毅力品尝到胜利的果实。但唯毅力论会让你“误入歧途”，一旦你坚持了很长一段时间，却收效甚微时，你会陷入深深的自我怀疑，是不是我还不够努力？为什么别人行，而我不行，是不是我太笨了？我再也不想学了。而一旦你放弃了，可能很长一段时间里，你都不会再碰它了。比如，我们学了那么久的英语，毕业后，还有多少人会碰呢？ 学习的最佳方法其实是“把学习变成习惯”。“习惯”是和风细雨，润物无声；“毅力”是狂风暴雨，电闪雷鸣。一个得了老年痴呆的老人，可能忘了家人，却忘不了回家的路，因为他已经习惯了。一个整天被父母打气加油的少年，可能会得神经衰弱，因为他承受高压，筋疲力尽。 关于学习习惯的养成，我放到最后再讲，先来说说如何学习盲打，主要是实操方法论，我坚信：授人以鱼，不如授人以渔。 学会降低认知负荷 学习盲打最主要的是指法，说到底，不过是搞清楚：十个手指，分别管那些键。其实是八个手指，两个大拇指只管空格键。初次学时，看着键盘上那么多键位，恐怕你脑壳都疼。这是因为认知负荷太大，我们不可能一下子把所有键位都学会，那是痴心妄想，所以很多人还没开始就已经结束了。这种情况下就需要降低“认知负荷”，即分解目标。两百级台阶，想想就觉得很累，但是跨过一两级台阶并不累，我们的目标也只关注这两级台阶，这个小目标很容易实现，认知负荷也低，不知不觉，登了不到100下，你成功登顶了。而不是像其他人一样站在底部望着高处，茫然无措，转身离去。学习盲打，同样如此，刚开始有点吃力，一天只学一个手指的键位好了，其他键位视而不见，然后是两个、三个，最后全部拿下。 当然了，降低认知负荷，包括两个维度，一个是降低任务复杂度，另一个是降低任务时长。 人的精力有限，做一件事尤其是一件无聊的事超过一定时间，大脑的警报系统就会报警。那么如何避开大脑的“警报系统”呢？ 不知道你有没有用过番茄钟，这是一种时间管理方法，一个番茄时间是25分钟，在这25分钟时间里，你要保持绝对的专注，每用完一个番茄时间，奖励自己5分钟休息时间，这样周而复始，良性循环，你就能很好地管理自己的时间了。一个小时太长，40分钟也长，25分钟够短了吧。这样，一天只学25分钟，只学一种指法，你不会太累，大脑的警报系统也就不会报警了。虽然如此，我还是把每天的学习时间降低到20分钟。 注意，我说了要降低认知负荷，但并不是说一点负荷也不要，就像锻炼身体一样，如果都没感觉累，说明你锻炼的还没到位，但是如果你太累了，对身体反而是有害的。关于学习的研究中有个“必要难度”理论，那些在课堂上狂记笔记的人，学习成绩往往并不好，反而是课堂上不做笔记，课下通过回忆做笔记的那些人，对知识的掌握更牢靠。也就是说，输入越难，输出越易。输入越易，输出越难。 我是怎么增加必要难度的呢？不光是练习指法，我还背指法，当天学习某个指法，我必须得知道该手指管那些键，不但如此，还得回忆出某个键归哪个手指管。等你真正掌握盲打后，你就会忘记这些，就像张无忌学太极剑，忘得干干净净时才真正学会。这时肌肉记忆已经让每个手指都知道了自己的归属地，完全不用过脑子。但刚开始时你必须得背指法，一天只记一个手指还是很容易记的，推荐用anki做成记忆卡片，根据记忆曲线来背诵。有时间我也会介绍下这个我心目中的学习神器。 利用打字软件及时反馈 有一本关于学习的畅销书叫《刻意练习》，“刻意练习”有一个重要的原则叫：及时反馈。我们练习盲打，绝对不是，打开记事本，对着某个文章就开始敲起来。而应该配合各种能够给予及时反馈的软件来练习。 我用的是Mac系统上的KeyKey，分为六个课程，每个课程达到满分时才会进入下一个课程，挑战过程中一旦出错就会发出刺耳的声音。如你所见，界面上有键位图，F和J上面也有下划线标识，F归左食指，J归右食指，这两个键位上都有微微的凸起，很好辨认。也就是说，从你开始练盲打起，就可以只看屏幕了。 Windows系统上推荐金山打字通。 记住一点，练习时间不要太长，超过二十分钟就要休息下，每天练习时间最好不要超过一个小时。哪怕你再想进步也不要铤而走险，否则之前的努力会毁于一旦。 利用锚定法养成微习惯 我已经将每天的学习时长缩短为20分钟，这个时间短到不会触发大脑的警报系统，但是大脑是不会帮你记着你要每天练习打字这回事的。这就凸显了习惯的重要性，学习不能全靠兴趣，兴趣是最好的老师，这没错，但这个老师可能随时转身离开。那么如何养成每天学习的习惯呢？ 想一想，你很少忘记刷牙吧。早上起床，夜晚睡前，我们就像条件反射一样拿起牙刷。看到关键字没，“早上起床、夜晚睡前”，有具体时间，有具体事件，这个事件每天都会发生，它就像墙上的钩子一样，刷牙这件事挂在了上边，这就是锚定法。 我为自己设计的锚定方法是：每天回家打开电脑，开始练盲打。有具体时间，具体事件，家我肯定是每天都回的，电脑也是每天都会打开的。如此一来，不需要调动太多资源，很快我就养成了每天练习盲打这个习惯。 最终，我根据上面这些原则，只用了一个星期就掌握了盲打。满打满算，也就两个多小时。 总结下： 学会分解目标，降低认知负荷 只做最小认知负荷以内的事 利用打字软件的及时反馈及时纠正 利用锚定法把习惯与固定的一个事件挂钩 接下来，开启你的盲打之旅吧！相信我，这会是个让你受益终身的技能！ ","link":"https://ixwu.github.io/how-do-i-master-touch-type-in-two-hours/"},{"title":"十分钟入门shell脚本","content":"在正式开始前，我们可以思考一个问题，学习一门技术难吗？不少人的答案可能是很难。 来看一个案例，也可以说是两个。 2017年苹果WWDC大会上，有两名开发者令世界瞩目。一个是已经82岁，来自日本的老太太，若宫正子；另一个是年仅10岁，来自澳大利亚的小朋友，Yuma。前者60岁时才接触电脑，81岁时用上Mac系统，然后花了半年时间开发出了自己的app；后者从6岁开始设计网站，随后四年为苹果商店贡献了五个app。有意思的是，两个人都有自己的编程课堂，老太太在自己家教老人电脑知识，小Yuma建了一个Youtube频道，叫 Anyone Can Code（人人皆可编程），主要教小孩编程。 或许有人想说，他们不过是天赋好罢了。但我只想说，这种想法不过是不敢跳出舒适区，为自己的懒惰和无能找借口罢了。 如今，各种底层技术已经经过层层封装，可以说，只要你有想法，编程甚至能够像搭积木一样简单。 首先，你有什么需求，你的这个需求可以被什么技术解决，了解它的基本概念，然后把它变成生活的一部分，想方设法用它。遇到问题了怎么办？把大问题拆分成小问题，找搜索引擎解答。 记住一点：你没必要学习某技术的所有知识，了解基本概念，基本原理，就可以用它了。 有人又会说了，我没啥需求怎么办？李敖曾说过：“作家不能等有了灵感才写作，一如妓女不能等有了性欲才接客。” 下面我们来学习shell脚本吧。主要面向linux初学者以及对linux感兴趣的人。请自行准备linux系统或Mac系统。 什么是Linux内核？ 我们大多知道操作系统，但少有人知道内核，像CenOS，Redhat，Ubuntu等，这是操作系统，内核是Linux kernel，它是操作系统的心脏，是操作系统的大脑，去掉它，操作系统将不复存在，你的电脑也会成为破铜烂铁。 不用过于深究，你可以简单地将内核看做电脑的大管家，它的小弟们与它一起构成了操作系统，共同管理计算机资源。 什么是shell？ 我们知道，计算机实际只懂0和1（二进制），我们与外国人沟通需要靠翻译，那么同计算机沟通当然也需要一个翻译，shell就是这个翻译。另外，你以为你是同计算机对话，其实不然，你实际上是同内核对话，你在电脑上看到的内存啊，磁盘啊，CPU等都是虚拟出来的，你的任何操作，最终都是由内核真正在计算机硬件上执行。 总结下shell定义： 一个命令语言解释器，你执行的命令都由它翻译给内核，由内核转交给CPU执行 是用户与内核之间的接口程序 不管是图形界面（GUI）还是命令行界面（CLI），用户的一切输入都先由shell解释后再交给内核 什么是bash shell？ shell的版本有很多像什么sh、bash、csh、ksh等，其中bash是Linux世界使用最广泛的shell，也是很多Linux发行版的默认shell。 获取当前系统可用shell [root@localhost ~]# cat /etc/shells /bin/sh /bin/bash /sbin/nologin /usr/bin/sh /usr/bin/bash /usr/sbin/nologin 查看当前使用的shell [root@localhost ~]# echo $SHELL /bin/bash 什么是CLI和GUI？ CLI：Command Line Interface（命令行接口） GUI：Graphical User Interface（图形用户接口） 顾名思义，CLI就是命令行界面，GUI就是图形界面 我们在电影看到的那些黑客的电脑界面，花花绿绿的，执行一条命令就会有一大堆输出的叫命令行界面，我们平时用的windows系统，用鼠标在上面点点点的，叫图形界面，Linux当然也有自己的图形界面 我们同shell对话，就是通过这两种接口进行的 尝试执行几个基本命令 [root@localhost ~]# echo &quot;hello,linux&quot; hello,linux [root@localhost ~]# date Sat Jan 12 23:48:13 CST 2019 什么是标准输入、标准输出和标准错误输出？ 或许你曾听说过：linux里面一切皆文件，所谓的标准输入、标准输出和标准错误输出其实都是文件 标准输入，缺省是终端键盘，所谓缺省，即系统默认状态 标准输出，缺省是终端屏幕，至于终端这个概念，你就简单理解为显示器加键盘吧 标准错误输出，缺省是终端屏幕 我们执行一条shell命令，就会打开这三个文件，你可以理解为三条管道，标准输入与键盘相连，标准输出和标准错误输出都默认与屏幕相连。没有特别指明的情况下，我们通过键盘输入的内容通过“标准输入”这条管道“流入”至相应的命令，命令的执行结果又会通过“标准输出”或“标准错误输出”这条管道“流出”至屏幕，展现在我们面前。 比如输入cat test.txt，cat这个命令作用是从命令行给出的文本中读取数据并将数据送到标准输出。 如果test.txt中有内容，那么标准输入就不是键盘了，而是该文件，文件内容通过“标准输入”这个“管道”流向cat命令，cat命令读取其内容，然后将内容“流出”至标准输出，即屏幕上。 # 将&quot;hello&quot;添加到test.txt这个文件中，如果不存在就创建 [root@localhost ~]# echo &quot;hello&quot; &gt; test.txt # 输出test.txt文件内容 [root@localhost ~]# cat test.txt hello #标准输出 假如test.txt不存在，那么就会报错，错误信息通过“标准错误输出”这条管道“流出”至屏幕上。 [root@localhost ~]# cat test.txt cat: test.txt: No such file or directory #标准错误输出 假如cat命令后面没有参数，那么其标准输入便是键盘了，终端就会等待我们输入，cat获取标准输入，通过“标准输出”这条管道输出到屏幕上。 [root@localhost ~]# cat hello # 标准输入 hello # 标准输出 什么是重定向？ 比如一条命令cat test.txt，它会把test.txt这个文件的内容输出到屏幕上，但我不想输出到屏幕上，我想保存到一个文件里，就可以用”标准输出重定向“符号&gt;将其重定向到某个文件cat test.txt &gt; temp.txt，这样屏幕上就没有输出，也就改变了标准输出的流出方向，故而称之为”重定向“。 &gt;又称为”覆盖重定向“，就是说会覆盖输出文件原先的内容。 &gt;&gt;被称为”追加重定向“，也就是说不会覆盖输出文件的内容，而是把输出追加到原内容的后面 &lt;被称为”标准输入重定向“，一般命令的标准输入都是键盘，用了&lt;，其标准输入就变成其后的文件了。比如，cat本身就能够以文件作为其标准输入，但我们也可以利用&lt;来将文件变成其标准输入：cat &lt; test.txt 前面又说了，所谓的标准输入、标准输出以及标准错误输出其实都是文件，是文件就会有文件描述符，就像人的名字一样，不然内核哪知道哪个文件是哪个文件啊。 标准输入的文件描述符是0，标准输出是1，标准错误输出是2。所以，如果我们想把cat test.txt的标准输出重定向到stdout.txt，其标准错误输出重定向到stderr.txt，可以这样做：cat test.txt 1&gt; stdout.txt 2&gt; stderr.txt,0和1一般都可以省略。 如何把标准错误输出与标准输出重定向到同一个文件？还是上面的例子：cat test.txt &gt; temp.txt 2&gt;&amp;1。还有一种方式是不区分标准错误输出与标准输出，统统重定向到同一个文件：cat test.txt &amp;&gt; temp.txt 什么是管道？ 前面我们了解到，命令的标准输出默认是屏幕，假如该命令的标准输出我们想再利用怎么办？那就需要利用管道了。强调一下，标准输出是指命令执行成功后的输出。 举个例子： [root@localhost ~]# echo “zhangsan” | useradd # 这条命令的意思是输出”zhangsan“，并利用useradd命令添加其为linux普通用户 # ”zhangsan“为管道前的标准输出，管道将其变成后面useradd命令的标准输入 注意事项： 管道只能处理前一个命令的标准输出，标准错误输出无法处理 管道后面的命令必须能够接受标准输入才行，像ls命令就不接受标准输入，所以它不能放在管道后面。ls命令的作用是列举目录下的内容，当然了，在linux世界怎么能接受不能呢，利用xargs就可以把管道前的标准输出当作ls命令的标准输入了 [root@localhost ~]# echo &quot;/etc&quot;| xargs ls # 没有xargs的话，这里的ls只能列举当前目录的内容，而非/etc这个目录 什么是shell脚本？ 前面说过，shell是一个命令语言解释器。另外，shell本身也是一个程序，有自己的命令，像什么ls、cd、pwd等都是其内置命令，还有一些其他命令，都是别人为linux添加的基本命令。我们知道，编程时通过各种库调用来实现功能，而shell没有库，他通过调用各种命令来实现相应功能。 我们通过输入各种命令与shell交互，但有时我们不想手动输入各种命令，我们想把命令存在一个文件中，然后让shell执行该文件中的命令，于是就有了shell脚本。 所谓的shell脚本其实就是一个包含一系列shell命令的文本，目的是减少重复工作，实现自动化。 shell脚本基本组件 shell脚本是由各种shell命令组成，但绝对不是简单的命令堆积，它像其他编程语言一样，有自己的基本组件。 shell命令 shell内部命令，如ls、cd、pwd等 其他命令 who、du、free等各种丰富的功能命令 数据结构 变量、数组、字典 函数 将一系列命令组合成一个函数，减少重复工作 控制流 if、case等分支语句 for、while等循环语句 如何快速编写一个脚本？ 脚本组成 一个完整的脚本有三部分组成：脚本声明、注释以及可执行语句。 脚本声明 前面说过，CPU只认识二进制，也就是说只能执行二进制程序文件 我们的脚本是文本文件，需要一个解释者解释下，也就是shell，shell本身是二进制程序 CPU运行shell程序，shell解释脚本的每一行内容，然后找到对应的二进制程序，由CPU执行 所以，首先我们得告诉CPU，该脚本用哪个解释器来解释 如何声明，在脚本第一行顶格写：#!/bin/bash #!被称为shebang符号，用来声明所使用的解释器，一旦执行某个脚本，CPU看到第一行，就会去执行该解释器，再由解释器去找对应的命令程序 /bin/bash指明bash二进制程序的位置 注释 简单的脚本还好，一旦复杂起来，可读性就大大降低，所以注释相当重要 解释器会忽略注释 shell脚本中的单行注释符号是# 至于多行注释，方法有很多，一般用不到的，想用的话，自己在网上搜搜 吧 可执行语句 linux命令以及相应的控制流与数据结构 相关语法可以在网上找 需要条件判断了，就搜shell if语法或shell case语法 需要重复执行某命令，就搜shell for循环或shell while循环 某个需求不知道用什么命令，就搜需求关键字好了 某个命令不知道怎么用，直接在命令行输入man 命令或者直接百度 一个批量ping ip脚本 说了这么多，让我们开始写一个脚本吧，先说一个命令，检测网络通不通，需要用到ping命令，我们想批量检测某一个网段的主机是否网络通畅，那就需要用到for循环。 #linux中默认编辑器通常是vi或vim，该文本编辑器分为三种模式 #默认是普通模式（无法输入内容，但可以通过相应命令操作文本），普通模式下按i表示进入插入模式（可以插入内容了） #按:表示进入命令行模式（批量操作文本），在插入模式或命令行模式下按ESC进入普通模式。输入ZZ或:wq退出vim编辑器 [root@localhost ~]# vim ping.sh #默认进入普通模式，先按i开始编写脚本，下面是脚本完整内容 #!/bin/bash NET=192.168.1 #声明一个变量并赋值 for i in {1..254} #后面的{1..254}表示循环范围从1-254，如果你就是想测试下，这里就改成{1..10}吧 do IP=$NET.$i #字符拼接并赋值给IP这个变量 ping -c 3 $IP &amp;&gt; /dev/null #-c指明发包次数，&amp;&gt; /dev/null表示无论正确输出还是错误输出统统丢弃 #$?表示上条命令的执行结果，0表示成功，非0表示失败 #-eq代表”是否等于“，[]是条件测试语法，测试条件左右必须各留至少一个空格 if [ $? -eq 0 ];then echo &quot;$IP is up&quot; else echo &quot;$IP is down&quot; fi done # 编写完毕，按ECS进入普通模式，然后输入:wq退出vim编辑器 脚本执行 执行脚本主要有三种方法： 直接运行脚本文件 这种方法需要脚本有可执行权限：chmod u+x ping.sh 然后输入脚本的绝对路径或相对路径来执行文件 比如相对路径，你得先进入脚本所在的目录，然后执行：./ping.sh 利用解释器执行 bash ping.sh sh ping.sh 利用source或. source ping.sh . ping.sh 第一种方法，如果你没有shebang语句（即第一行声明解释器），可能会报错；第二种方法，你可以不声明解释器类型，因为你是直接用解释器来执行的，也可以不赋予执行权限；第三种方法，你是在当前shell环境来执行的，前两种实际上都是在子shell中执行，执行完毕才退回到当前shell。 基本上用哪种方法都行，看你心情。 # 假如你想把执行结果保存到一个文件，也就会利用输出重定向 # 但同时你又想输出其结果到屏幕上，那就会用到tee命令了 [root@localhost ~]# bash ping.sh | tee out.txt 192.168.1.1 is up 192.168.1.2 is down ... #现在你想知道有多少个ip是通的，这就用到涉及文本过滤命令grep以及统计命令wc [root@localhost ~]# grep &quot;up&quot; out.txt | wc -l 3 最后补充一点，同window不同，linux世界，文件后缀没有任何意义，加后缀名只是方便人类自己查看。 学习一门新技术，最痛苦的过程只是前两小时，熬过了这两小时，后面就会越走越顺。 ","link":"https://ixwu.github.io/shell-scripts-abc/"},{"title":"Centos7上安装 elasticsearch-6.2.2及相关插件","content":"elasticsearch是一个开源的搜索服务器，提供了一个分布式多用户能力的全文搜索引擎，下面是我的安装笔记 准备工作 java版本 jdk版本必须是1.8及1.8以上 [root@localhost ~]# java -version java version &quot;1.8.0_161&quot; Java(TM) SE Runtime Environment (build 1.8.0_161-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode) 创建es用户 elasticsearch6 不允许root用户安装和使用，需要另外创建用户 [root@localhost ~]# useradd es &amp;&amp; echo &quot;es123&quot; | passwd --stdin es 修改 /etc/security/limits.conf [root@localhost ~]# vim /etc/security/limits.conf # 修改系统最大文件描述符限制 * soft nofile 262144 * hard nofile 262144 # 修改系统锁内存限制 es soft memlock unlimited es hard memlock unlimited # 更改用户可启用的最大线程数 * hard nproc 4096 * soft nproc 4096 修改 /etc/sysctl.conf [root@localhost ~]# vim /etc/sysctl.conf vm.max_map_count = 262144 vm.swappiness = 1 # 禁用swapping 使修改生效 [root@localhost ~]# sysctl -p 安装 elasticsearch-6.2.2 下载解压 [root@localhost ~]# cd /usr/local/src [root@localhost src]# wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.2.tar.gz [root@localhost src]# tar xzvf elasticsearch-6.2.2.tar.gz [root@localhost src]# mv elasticsearch-6.2.2 /opt 修改elasticsearch-6.2.2目录权限 将该目录下所有文件的属主与属组均改为es [root@localhost src]# chown -R es:es /opt/elasticsearch-6.2.2/ 创建数据目录与日志目录 注意：后续操作需要切换至es账户 [root@localhost src]# su - es [es@localhost src]$ cd /opt/elasticsearch-6.2.2/ [es@localhost elasticsearch-6.2.2]$ mkdir -p elasticsearchdata/{data,log} 修改配置文件 [es@localhost elasticsearch-6.2.2]$ cd /opt/elasticsearch-6.2.2/conf [es@localhost conf]$ vim elasticsearch.yml # 需要修改 cluster.name，node.name，path.data等参数值 cluster.name: app_es # 集群名字 node.name: node-1 # 节点名字 path.data: /opt/elasticsearch-6.2.2/elasticsearchdata/data # 指定数据存放路径 path.logs: /opt/elasticsearch-6.2.2/elasticsearchdata/log # 指定日志存放路径 bootstrap.memory_lock: false network.host: 0.0.0.0 # Set the bind address to a specific IP http.port: 9200 # 默认是9200，你也可以通过修改其值自定义端口 transport.tcp.port: 9300 # 默认是9300，可自定义 # 集群发现 #集群节点ip或者主机，在这里添加各节点ip discovery.zen.ping.unicast.hosts: [&quot;ip1:9300&quot;, &quot;ip2:9300&quot;，&quot;ip3:9300&quot;] # 设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值（2-4） discovery.zen.minimum_master_nodes: 3 启动服务 [es@localhost elasticsearch-6.2.2]$ /opt/elasticsearch-6.2.2/bin/elasticsearch #前台启动 [es@localhost elasticsearch-6.2.2]$ nohup /opt/elasticsearch-6.2.2/bin/elasticsearch &amp; #后台启动 测试服务是否启动成功 看到9200和9300端口就ok了,其中9300是es节点tcp通讯端口,9200是RESTful接口 [es@localhost ~]$ netstat -lntp | grep -E &quot;9200|9300&quot; (Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.) tcp 0 0 0.0.0.0:9200 0.0.0.0:* LISTEN 1022/java tcp 0 0 0.0.0.0:9300 0.0.0.0:* LISTEN 1022/java 在浏览器输入 http://你的ip:9200，可看到如下内容 { &quot;name&quot; : &quot;node-1&quot;, &quot;cluster_name&quot; : &quot;app_es&quot;, &quot;cluster_uuid&quot; : &quot;...&quot;, &quot;version&quot; : { &quot;number&quot; : &quot;6.2.2&quot;, &quot;build_hash&quot; : &quot;10b1edd&quot;, &quot;build_date&quot; : &quot;2018-02-16T19:01:30.685723Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;7.2.1&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot; } 证明启动成功 解决启动报错 错误一：Cannot allocate memory Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000ca660000, 899284992, 0) failed; error='Cannot allocate memory' (errno=12) There is insufficient memory for the Java Runtime Environment to continue. Native memory allocation (mmap) failed to map 899284992 bytes for committing reserved memory. An error report file with more information is saved as: /opt/elasticsearch-6.2.2/hs_err_pid17955.log 由以上错误信息可知，分配给java的内存不足，elasticsearch6.2 默认分配 jvm 空间大小为1g，这个虚机的内存大小不足，需要修改 jvm 空间分配，我们可以将1g改成512m [es@localhost ~]$ vim /opt/elasticsearch-6.2.2/config/jvm.options -Xms1g 修改为 -Xms512m -Xmx1g 修改为 -Xmx512m 错误二：文件描述符不足 ERROR: [3] bootstrap checks failed [1]: max file descriptors [65535] for elasticsearch process is too low, increase to at least [65536] [2]: memory locking requested for elasticsearch process but memory is not locked [3]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 如何你按我的教程顺序来就不会发生这个错误，请参照准备工作这一节，修改相应的内核参数 错误三：不能以root启动 不能以root身份来启动es服务，需要以相应的es来启动 插件下载 下载中文分词器 elasticsearch-analysis-ik 插件 [es@localhost ~]$ /opt/elasticsearch-6.2.2/bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip 下载 elasticsearch-head 插件 head插件是elasticsearch的客户端工具 # 下载必要组件 [root@localhost ~]# yum -y install nodejs npm git bzip2 [root@localhost ~]# cd /opt/ [root@localhost opt]# git clone https://github.com/mobz/elasticsearch-head.git [root@localhost opt]# npm install -g grunt-cli [root@localhost opt]# cd /opt/elasticsearch-head [root@localhost /opt/elasticsearch-head]# npm install # 修改Gruntfile.js [root@localhost opt]# cd /opt/elasticsearch-head [root@localhost /opt/elasticsearch-head]# vim Gruntfile.js # 在appcss后添加server块 appcss: { src: fileSets.srcCss, dest: '_site/app.css' }, server: { options: { hostname: '*', port: 9100, base: '.', keepalive: true } } }, ## 对外开放端口为9100，允许任何主机访问 # 修改elasticsearch-head默认连接地址 ## 修改head/_site/app.js，修改head连接es的地址（修改localhost为本机的IP地址） [root@localhost /opt/elasticsearch-head]# cd _site [root@localhost _site]# vim app.js ## 将localhost修改为es服务的IP地址 修改前：this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://localhost:9200&quot;; 修改后： this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://你的ip:9200&quot;; # 启动head服务 [root@localhost _site]# cd /opt/elasticsearch-head/node_modules/grunt/bin/ [root@localhost bin]# nohup ./grunt server &amp; # 修改 elasticsearch-6.2.2 配置文件 [root@localhost opt]# su - es [es@localhost opt]$ vim /opt/elasticsearch-6.2.2/config/elasticsearch.yml ## 在配置文件最后添加下面两条 http.cors.enabled: true # 允许跨域访问，为了配合elasticsearch-head可视化ES界面 http.cors.allow-origin: &quot;*&quot; # 允许所有地址跨域访问 ## 然后重启es服务 在浏览器输入：http://你的ip:9100，开始使用es服务吧 ","link":"https://ixwu.github.io/howto-setup-elasticsearch-6.2.2-in-centos/"},{"title":"一个 jar 包启动脚本","content":"一个启 jar 包的脚本，你希望它还能有什么功能？ 我希望它还能停止，重启，上线，回滚，能查看运行状态，能查看日志，于是有了下面这个脚本。 如何使用？ # 在你放脚本的地方执行下面这条命令下载脚本，本例是放在root目录下 [root@localhost ~]# curl -s https://devops.xwlearn.com/shell/boot-jar.sh &gt; boot-jar.sh # 查看使用帮助 [root@localhost ~]# bash boot-jar.sh ======================================================================== usage: boot-jar.sh [option] ... [start | stop | status | restart | log | upgrade] bash boot-jar.sh start : start service # 启动服务 bash boot-jar.sh stop : stop service # 停止服务 bash boot-jar.sh status : service status # 查看运行状态 bash boot-jar.sh log : service log # 查看日志 bash boot-jar.sh restart : restart service # 重启服务 bash boot-jar.sh upgrade/up : upgrade service # 更新包 bash boot-jar.sh rollback/back: rollback service # 回滚包 ======================================================================== # 修改变量 [root@localhost ~]# vim boot-jar.sh UPLOAD_PATH= # 上包目录，如/opt/upload DEPLOY_PATH= # jar包安装路径,如/opt/test PACKAGE_NAME= # jar包名,如test-hello-1.0.0.jar SERVICE_NAME=${PACKAGE_NAME%-*} # 去掉后缀及版本号,本例为test-hello LOG_NAME=${SERVICE_NAME}.log # 日志名，本例为test-hello.log ACTIVE=&quot;test&quot; # 启动相应环境配置，如test|pre|pro PACKAGE_PATH=$DEPLOY_PATH/$PACKAGE_NAME # 安装包路径,本例为 /opt/test/test-hello-1.0.0.jar LOG_PATH=$DEPLOY_PATH/logs/$LOG_NAME # 日志路径,本例为 /opt/test/logs/test-hello.log BACKUP_PATH=$DEPLOY_PATH/backup # 备份目录,本例为 /opt/test/backup BACKUP_LAST=$(find $BACKUP_PATH -name &quot;${PACKAGE_NAME}*&quot; | xargs ls -t | head -1) BACKUP_LAST_NAME=$(basename $BACKUP_LAST) # 上一个备份包文件名 ...... # 按照上面例子，需提前创建好相关目录 上包目录 /opt/upload jar包安装目录 /opt/test 日志目录 /opt/test/logs 备份目录 /opt/test/backup # 这里利用花括号的扩展功能快速创建目录及子目录，下面脚本中会有花括号另一个妙用 [root@localhost ~]# mkdir -p /opt/{upload,test/{logs,backup}} [root@localhost ~]# tree /opt [root@vultr ~]# tree -L 2 /opt /opt ├── test │ ├── backup │ └── logs ├── upload ... # 把你的jar包放入 /opt/upload 就行了 [root@localhost ~]# bash boot-jar.sh upload # 上包并启动服务 [root@localhost ~]# bash boot-jar.sh status # 查看运行状态 # 还可以把你的脚本目录放入path，就可以全局执行了 [root@localhost ~]# chmod u+x boot-jar.sh [root@localhost ~]# vim /etc/profile.d/boot-jar.sh export PATH=&quot;$PATH:/root&quot; [root@localhost ~]# source /etc/profile.d/boot-jar.sh [root@localhost ~]# boot-jar.sh upload # 上包并启动服务 [root@localhost ~]# boot-jar.sh status # 查看运行状态 [root@localhost ~]# boot-jar.sh log # 查看日志 ...... 在展示完整脚本前，我先介绍下它的几个亮点。 如何判断某程序是否安装？ # 比如 java [root@localhost ~]# command -v java 为什么用 command 判断？而非 which command 是 bash 内置命令，性能更好; 而 which 是外部命令，性能低些，这还不是主要的，我们来看看这两个命令的定义： Run command with args suppressing the normal shell function lookup. Only builtin commands or commands found in the PATH are executed If either the -V or -v option is supplied, a description of command is printed ...... If the -V or -v option is supplied, the exit status is 0 if command was found, and 1 if not. 由上可知，command是运行系统真正的命令，而非别名。换种说法，你先查看下你的ls命令别名 [root@localhost ~]# alias ls alias ls='ls --color=auto' 所以说你键入ls命令时，实际运行的是ls --color=auto，假如有人把ls变成rm -rf /，你是不是该跑路了？ command命令能让你只运行真正的ls，而非其别名。其-v选项是打印给定命令的简要描述，是别名的输出别名，不是的打印其命令路径，内置命令就输出其名称。更重要的是，它明确告诉你，如果找到了命令，就退出0，找不到就退出1，我们就利用这点判断系统是否安装某命令，注意，如果你安装了某应用，但是没有把它加入PATH，那就没法判断了。 再来看看which shows the full path of (shell) commands Which returns the number of failed arguments, or -1 when no `programname´ was given which 主要是用来寻找命令的完整路径，其返回值是失败参数个数，也就是说which后面可跟多个参数，都找到了就返回0，失败一个返回1，失败n个返回n。没有给定参数，返回-1，也就是255，这是因为exit只能使用0~255之间的值，-1 的unsigned值便是255。 看起来好像which也能根据返回状态码判断某程序是否安装？但是which是外置命令，不同系统上的which实现方式是不一样的，很多系统上的which甚至不设置退出状态码，这样不管你找没找到某程序，都返回0，请问你如何判断？ 除了command，type和hash这两个内置命令也可以判断，具体请看stackoverflow 写成函数 function check_cmd() { command -v $1 &gt;/dev/null 2&gt;&amp;1 || { echo &gt;&amp;2 &quot; \\033[31m $1 is not installed. Aborting. \\033[0m&quot;; exit 1; } } 这里的花括号其实是一个匿名函数，所以里面的语句末尾都得加分号。在这里查看更多shell中括号的总结 如何获得运行程序的pid？ 通常做法是 PID=$(ps -ef |grep -v grep |grep &lt;keyword&gt; |awk '{print $2 }') 这种方法不是不能用，但是我觉得不够优雅，最优雅的方式是使用pgrep命令，上述命令可以改成 PID=$(pgrep -f &lt;keyword&gt;) The pattern is normally only matched against the process name. When -f is set, the full command line is used. The running pgrep or pkill process will never report itself as a match 如何获得上一条命令的最后一个参数？ 命令行中可以用!，这是与‘history‘命令相关的特殊变量，脚本中就不可以这样了，通用做法是‘，这是与`history`命令相关的特殊变量，脚本中就不可以这样了，通用做法是`，这是与‘history‘命令相关的特殊变量，脚本中就不可以这样了，通用做法是‘_`，命令行和脚本中都可以。这个是我自己试出来了的，墙内还没找到相关资料，刚刚为了印证，才翻了墙找了找，果然如我所料。 mkdir test &amp;&amp; cd $_ # 创建test目录并进入 # 通常我们进入目录前最好判断该目录是否存在，可以用 []、[[]]以及test来进行条件测试，但知道了$_后，我通通改成下面这样，因为用了 [ ] 和 [[ ]] 就不能使用$_ test -d test &amp;&amp; cd $_ # 万一不存在test目录，而我们希望创建后然后又进去，该如何做呢？ test -d test &amp;&amp; cd $_ || mkdir $_ &amp;&amp; cd $_ # 这就有点多余了，我们来优化下 test -d test || mkdir $_ &amp;&amp; cd $_ # 扩展，删除文件时我们也会判断下某文件是否存在，比如 [ -f /usr/local/src/justfortest.md ] &amp;&amp; rm -f /usr/local/src/justfortest.md # 这就显得臃肿了，我们来优化下 test -f /usr/local/src/justfortest.md &amp;&amp; rm -f $_ 完整脚本 #!/bin/bash UPLOAD_PATH= # 上包目录 DEPLOY_PATH= # 安装路径 PACKAGE_NAME= # 包名 SERVICE_NAME=${PACKAGE_NAME%-*} # 切割包名，去掉后缀及版本号 LOG_NAME=${SERVICE_NAME}.log # 日志名 ACTIVE=&quot;test&quot; # 运行环境 test|pre|pro PACKAGE_PATH=$DEPLOY_PATH/$PACKAGE_NAME # 安装包路径,如果是war的话, 改为$DEPLOY_PATH/webapps/$PACKAGE_NAME，$DEPLOY_PATH 值为tomcat路径，如/data/tomcat LOG_PATH=$DEPLOY_PATH/logs/$LOG_NAME # 日志路径 BACKUP_PATH=$DEPLOY_PATH/backup # 备份目录 BACKUP_LAST=$(find $BACKUP_PATH -name &quot;${PACKAGE_NAME}*&quot; | xargs ls -t | head -1) BACKUP_LAST_NAME=$(basename $BACKUP_LAST) RETVAL=&quot;0&quot; function check_ok() { if [ $? != 0 ] then echo -e &quot;\\033[31m ERROR! $1 \\033[0m&quot; exit 1 fi } function check_cmd() { command -v $1 &gt;/dev/null 2&gt;&amp;1 || { echo &gt;&amp;2 &quot; \\033[31m $1 is not installed. Aborting. \\033[0m&quot;; exit 1; } } function get_pid() { PID=$(pgrep -f $PACKAGE_NAME) } function backup() { local TIMESTAMP=$(date +%F-%H-%M) test -d $BACKUP_PATH || mkdir -p $_ test -f $PACKAGE_PATH &amp;&amp; mv -b $_ $BACKUP_PATH/${PACKAGE_NAME}_${TIMESTAMP} } function upload() { test -d $UPLOAD_PATH || mkdir -p $_ # 判断上包目录是否存在新包 if [ -f $UPLOAD_PATH/$PACKAGE_NAME ];then # 关服务 stop check_ok &quot;stop $SERVICE_NAME&quot; # 判断安装目录是否存在 test -d $DEPLOY_PATH || mkdir -p $_ backup mv $UPLOAD_PATH/$PACKAGE_NAME $DEPLOY_PATH # 起服务 start else echo -e &quot; \\033[31m there is no new package in $UPLOAD_PATH \\033[0m&quot; exit 1 fi } function rollback() { # 停服务 stop # 删除安装目录中的包 test -f $PACKAGE_PATH &amp;&amp; rm -f $_ # 回滚上一个包 test -f $BACKUP_PATH/$BACKUP_LAST_NAME &amp;&amp; mv $_ $PACKAGE_PATH # 起服务 start } function start() { # 先判断java是否存在 check_cmd java #local PID=$(pgrep -f $PACKAGE_NAME) get_pid if [ ${PID} ]; then echo -e &quot; $SERVICE_NAME is running, please run \\033[34m $0 stop \\033[0m first&quot; exit 1 fi # 先判断日志文件是否存在 test -d $DEPLOY_PATH/logs || mkdir -p $_ cd $DEPLOY_PATH/logs test -f $LOG_NAME || touch $_ # 判断安装目录中是否有包 test -f $PACKAGE_PATH || { echo &quot;there is no package in $_&quot;;exit 1;} nohup java -jar $PACKAGE_PATH --spring.profiles.active=$ACTIVE &gt; $LOG_PATH 2&gt;&amp;1 &amp; check_ok &quot;running java -jar ...&quot; echo -e &quot;$SERVICE_NAME \\033[34m Started \\033[0m&quot; echo -e &quot;查看日志命令：\\033[34m $0 log \\033[0m 或者 \\033[34m tail -f $LOG_PATH \\033[0m&quot; } function stop() { #local PID=$(pgrep -f $PACKAGE_NAME) get_pid if [ ${PID} ]; then echo $SERVICE_NAME 'Stop Process'[${PID}] kill -15 $PID fi sleep 5 # local PID=$(pgrep -f $PACKAGE_NAME) get_pid if [ ${PID} ]; then echo $SERVICE_NAME' Kill Process'[${PID}] kill -9 $PID else echo $SERVICE_NAME' Stop Success!' fi } function status(){ #local PID=$(pgrep -f $PACKAGE_NAME) get_pid if [ &quot;$PID&quot; != &quot;&quot; ]; then echo -e &quot;$SERVICE_NAME is \\033[34m Running \\033[0m [$PID] &quot; else echo -e &quot;$SERVICE_NAME is \\033[31m Stopped \\033[0m &quot; fi } function log(){ tail -100f $LOG_PATH } function usage(){ echo &quot;========================================================================================&quot; echo -e &quot;\\033[34m usage: $0 [option] ... [start | stop | status | restart | log | upgrade]\\033[0m&quot; echo -e &quot;\\033[34m bash $0 start \\033[0m : start service&quot; echo -e &quot;\\033[34m bash $0 stop \\033[0m : stop service&quot; echo -e &quot;\\033[34m bash $0 status \\033[0m : service status&quot; echo -e &quot;\\033[34m bash $0 log \\033[0m : service log&quot; echo -e &quot;\\033[34m bash $0 restart \\033[0m : restart service&quot; echo -e &quot;\\033[34m bash $0 upgrade/up\\033[0m : upgrade service&quot; # 升级服务 echo -e &quot;\\033[34m bash $0 rollback/back\\033[0m: rollback service&quot; # 回滚服务 echo &quot;========================================================================================&quot; RETVAL=&quot;2&quot; } RETVAL=&quot;0&quot; case &quot;$1&quot; in start) get_pid if [ $PID ];then echo -e &quot; $SERVICE_NAME is running, please run \\033[34m $0 stop \\033[0m or \\033[34m $0 restart \\033[0m&quot; else start fi ;; stop) echo &quot;will stop $SERVICE_NAME&quot; stop ;; restart) echo &quot;will stop $SERVICE_NAME&quot; stop echo &quot;will start $SERVICE_NAME&quot; start ;; upgrade|up) echo &quot;will upgrade $SERVICE_NAME&quot; upload ;; log) log ;; status) status ;; rollback|back) echo &quot;will rollback to the last version&quot; rollback ;; *) usage ;; esac exit $RETVAL ","link":"https://ixwu.github.io/start-up-script-of-jar-package/"},{"title":"编译安装GraphicsMagick-1.3.28","content":"GraphicsMagick 号称为图像处理领域的瑞士军刀，下面是我的安装笔记，如果你想一键安装可以在命令行运行 curl -s https://devops.xwlearn.com/shell/gmagick.sh | bash source /etc/profile.d/gmagick.sh 系统版本 [root@localhost local]# uname -r 3.10.0-693.2.2.el7.x86_64 [root@localhost local]# cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) 官网地址 ftp://ftp.graphicsmagick.org/pub/GraphicsMagick/ 下载版本 GraphicsMagick-1.3.28 下载依赖 yum install -y libjpeg-devel libjpeg yum install -y libpng-devel libpng yum install -y giflib-devel giflib 安装过程 # 下载 wget ftp://ftp.graphicsmagick.org/pub/GraphicsMagick/1.3/GraphicsMagick-1.3.28.tar.gz # 解压 tar -zxvf GraphicsMagick-1.3.28.tar.gz cd GraphicsMagick-1.3.28 #编译 ./configure --prefix=/usr/local/GraphicsMagick-1.3.28 --with-quantum-depth=8 --enable-shared --enable-static make &amp;&amp; make install # 创建软链 ln -s /usr/local/GraphicsMagick-1.3.28 /usr/local/GraphicsMagick 设置环境变量 vim /etc/profile.d/gmagick.sh export GMAGICK_HOME=&quot;/usr/local/GraphicsMagick&quot; export PATH=&quot;$GMAGICK_HOME/bin:$PATH&quot; LD_LIBRARY_PATH=$GMAGICK_HOME/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH 生效配置 source /etc/profile.d/gmagick.sh 测试 gm convert -list formats 如果列表中显示PNG、JPEG、GIF等则表示已支持图片转换 一键安装脚本 我现在养成了一个习惯，每写一篇文档就会写一份相应的脚本，下面这个脚本已经在CentOS7和CentOS6环境测试过 #!/bin/bash SRC_PATH=/usr/local/src #源码安装目录 SRC_URL=ftp://ftp.graphicsmagick.org/pub/GraphicsMagick/1.3/GraphicsMagick-1.3.28.tar.gz #源码地址 PACKAGE_NAME=$(basename $SRC_URL) # GraphicsMagick-1.3.28.tar.gz PACKAGE_FILE=$(basename $PACKAGE_NAME .tar.gz) # GraphicsMagick-1.3.28 PACKAGE_NAME_PURE=${PACKAGE_FILE%-*} # GraphicsMagick INSTALL_PATH=/usr/local # 应用安装目录 check_ok() { if [ $? != 0 ] then echo -e &quot;\\033[31m ERROR! $1 \\033[0m&quot; exit 1 fi } check_yum() { if ! rpm -qa|grep -q &quot;^$1&quot; then yum install -y $1 check_ok else echo -e &quot;\\033[34m $1 already installed \\033[0m.&quot; fi } deploy-gmagick() { # 下载依赖，把需要的依赖放在一个数组里 arr_package=(&quot;libjpeg-devel&quot; &quot;libjpeg&quot; &quot;libpng-devel&quot; &quot;libpng&quot; &quot;giflib-devel&quot; &quot;giflib&quot;) for package in ${arr_package[@]};do check_yum $package done # $_ 代表上一个命令最后一个参数 test -d $SRC_PATH &amp;&amp; cd $_ || mkdir -p $_ &amp;&amp; cd $_ # 如果已经安装了就不需要下载了 if [ ! -f $PACKAGE_NAME -a ! -d $PACKAGE_FILE ];then wget $SRC_URL check_ok &quot;download $PACKAGE_NAME_PURE&quot; tar zxvf $PACKAGE_NAME check_ok &quot;tar xf $PACKAGE_NAME_PURE&quot; elif [ -f $PACKAGE_NAME -a ! -d $PACKAGE_FILE ];then tar zxvf $PACKAGE_NAME check_ok &quot;tar xf $PACKAGE_NAME_PURE&quot; else echo &quot;you have installed $PACKAGE_FILE &quot; fi cd $PACKAGE_FILE ./configure --prefix=$INSTALL_PATH/$PACKAGE_FILE --with-quantum-depth=8 --enable-shared --enable-static check_ok &quot;configure&quot; make &amp;&amp; make install check_ok &quot;make install&quot; test -d $INSTALL_PATH || mkdir -p $_ test -h $INSTALL_PATH/$PACKAGE_NAME_PURE &amp;&amp; rm -f $_ ln -s $INSTALL_PATH/$PACKAGE_FILE $INSTALL_PATH/$PACKAGE_NAME_PURE } config-gmagick(){ # 利用 here document 创建环境变量 cat &gt;&gt; /etc/profile.d/gmagick.sh &lt;&lt; EOF export GMAGICK_HOME=&quot;$INSTALL_PATH/$PACKAGE_NAME_PURE&quot; export PATH=&quot;\\$GMAGICK_HOME/bin:\\$PATH&quot; LD_LIBRARY_PATH=\\$GMAGICK_HOME/lib:\\$LD_LIBRARY_PATH export LD_LIBRARY_PATH EOF source /etc/profile.d/gmagick.sh # 如果用bash执行这个脚本的话，此处不会生效，需要手动在命令行重新执行一次 source /etc/profile.d/gmagick.sh } deploy-gmagick check_ok &quot;deploy-gmagick&quot; echo &quot;start to configure GgraphMagick&quot; config-gmagick [ $? == &quot;0&quot; ] &amp;&amp; echo &quot;SUCCESS&quot; ","link":"https://ixwu.github.io/howto-compile-GraphicsMagick-1.3.28/"},{"title":"如何替换jar/war包里的文件","content":"要替换的文件在 jar/war 包的根目录 # 如要替换 test.war 包里的 test.xml [xuwu@localhost ~]$ jar uvf test.war test.xml 要替换的文件在 jar/war 包的其他目录 # 如果不知道想改的文件在哪个目录，可以用 grep 查看下 [xuwu@localhost ~]$ jar tvf test.war | grep application.yml 507 Tue Dec 25 09:45:48 CST 2018 WEB-INF/classes/application.yml ## 解压该文件,该目录下会生成该文件的目录结构 [xuwu@localhost ~]$ jar xvf test.war [xuwu@localhost ~]$ ll drwxrwxr-x 3 xuwu xuwu 4096 12月 6 21:54 META-INF drwxrwxr-x 4 xuwu xuwu 4096 12月 6 21:54 WEB-INF ## 修改 WEB-INF/classes/application.yml 修改的内容，然后替换 war 包相应文件 [xuwu@localhost ~]$ jar uvf test.war WEB-INF/classes/application.yml 扩展 可以把与环境相关的文件直接放在服务器上，上线时用服务器本地的文件替换，防止开发打错包 增量打包，很多时候开发只是修改其中一个文件，没必要重新打包，直接替换该文件即可 jar 常见用法 # 解压 .jar/.war 文件到当前目录 jar -xvf file.jar # 列出 .jar/.war 文件内容 jar -tf file.jar -v 在标准输出中生成详细输出 -u 更新现有文件 -c 创建新归档文件 -f 指定归档文件名 -x 解档文件 -t 列出归档文件内容 -0 仅存储; 不使用任何 ZIP 压缩（把jar包放进war必须把这个参数加上） ","link":"https://ixwu.github.io/howto-replace-file-in-war-package/"},{"title":"vim高尔夫解说之逗号问题","content":"vim 是 vi 编辑器的升级版，是 Linux 世界最为著名的一款文本编辑器，国外有个叫 vimgolf 的网站,将 vim 操作比作打高尔夫球，里面设计了很多挑战，你可以在那里测试、提高自己的 vim 水平。 那么，如何衡量你的vim水平？ 最简单粗暴的方式就是计算击键数，修改同样一段文本，击键次数越少，水平越高，一键对应一分，即分数越少，水平越高。 下面这个挑战叫：逗号问题 初始文本 ,0,1,2,3,4,5,6,7,89 ,1,2,3,4,5,6,7,8,90 ,2,3,4,5,6,7,8,9,01 ,3,4,5,6,7,8,9,0,12 ,4,5,6,7,8,9,0,1,23 56,7,8,9,0,1,2,3,4, 67,8,9,0,1,2,3,4,5, 78,9,0,1,2,3,4,5,6, 89,0,1,2,3,4,5,6,7, 90,1,2,3,4,5,6,7,8, 目标文本 0,1,2,3,4,5,6,7,8,9 1,2,3,4,5,6,7,8,9,0 2,3,4,5,6,7,8,9,0,1 3,4,5,6,7,8,9,0,1,2 4,5,6,7,8,9,0,1,2,3 5,6,7,8,9,0,1,2,3,4 6,7,8,9,0,1,2,3,4,5 7,8,9,0,1,2,3,4,5,6 8,9,0,1,2,3,4,5,6,7 9,0,1,2,3,4,5,6,7,8 观察初始文本与目标文本差异可知，作者的目标是，除了第一列前和最后一列后无逗号，其余每一位数字均由,隔开，原始文本需要改的地方是： 前五行 第一列逗号删掉 最后一列两位数字用,分隔开 后五行 第一列两位数字用,分隔开 最后一列逗号删掉 知道了不同，现在就让我们瞄准目标，开始打vim高尔夫吧！ready go！ 第一局：29分 第一局，我的得分是29分，也就是击了29键。既然是批量操作，我首先想到的是命令模式，该模式也被称为冒号模式，因为以冒号开头。 :1,5norm x$P&lt;CR&gt; 首先输入:进入命令模式，要操作前五行，需输入1,5，这里1也可以换成.，因为进入文件时，光标在第一行，命令模式中.代表光标所在行 norm是normal的缩写（可以省两键），即普通模式，两个模式各有千秋，普通模式擅长近程攻击，操作范围窄；命令模式适合远程攻击，操作范围广，二者优势互补，珠联璧合。 norm后空一格以输入普通模式命令，删(x)第一个字符（,），跳到行位($在普通模式中是指作用到行尾)，在最后一个字符前粘贴(P)之前删掉的字符（,），按&lt;CR&gt;（Enter）键执行操作 至此，首轮操作完毕，光标跳到第5行倒数最后一个逗号上 :6,$norm $x0p&lt;CR&gt;ZZ 同样是在命令模式中调用普通模式，操作范围是第6行到最后一行，$在命令模式中代表最后一行。 $x代表挑战到行尾，然后删掉最后一个字符（,），因为操作范围是最后五行，所以最后一列的逗号都会被删掉 0代表绝对行首，也可以叫它硬行首，软行首是^,光标跳转到行首后，执行p，就会粘贴刚才删掉的逗号，删掉的字符会保存在寄存器中，大写的p在光标前粘贴寄存器中的字符，小写的p在光标后粘贴寄存器中的字符。按&lt;CR&gt;（Enter）键执行操作 至此全部修改完成，但是别忘了，我们还要保存退出的，这里用的是ZZ，还可以用:wq和:x，不过命令模式执行需要按&lt;CR&gt;（Enter）键，这样一来，:wq需要按四个键，:x需要按三个键，而ZZ只需要按两个键便可 第二局：26分 使用命令模式虽然简单易懂，但是局限也很明显，那就是无法再降低击键数了，这次我们换一个模式：可视模式，所谓可视模式其实还是在普通模式中，只不过可以像鼠标一样选中字符、行、块。 &lt;C-V&gt;4jx$&lt;C-V&gt;4jI,&lt;Esc&gt;6G&lt;C-V&gt;4jA,&lt;Esc&gt;$&lt;C-V&gt;4jdZZ &lt;C-V&gt;(ctrl+v)进入块选择模式，我们想操作前五行的第一列，就向下选中4行（执行4j），删除(x)第一列逗号; $&lt;C-V&gt;4jI,&lt;Esc&gt;，意思是跳到行尾，进入可视化模式，选中前五行最后一列，在选中列开头插入逗号，然后按ESC退出插入模式 6G&lt;C-V&gt;4jA,&lt;Esc&gt;，意思是跳到第6行（普通模式中跳转到第n行，命令是nG），进入可视化模式，选中后五行第一列，在选中列末尾插入逗号，然后按ESC退出插入模式 $&lt;C-V&gt;4jdZZ，意思是跳到行尾，进入可视化模式，选中后五行最后一列，然后删除该列，最后按ZZ保存退出 第三局：19分 第二次尝试虽然比第一次降低3次按键，但是还有很大的优化空间，我们先把他放在一边，这次我们换一种方式，利用 vim 的录制宏来操作。 qa&lt;C-V&gt;4jx6G$q@a0p{$PZZ qa输完就代表开始录制了，接下来的操作&lt;C-V&gt;4jx6G$，先是删除前五行第一列第一个字符, 然后6G跳转到第6行，$跳转到该行尾部，q@a代表结束录制，然后重复一次刚才的操作，后五行最后一个字符便被删掉了 0p回到第六行行首，并在第一列后粘贴刚才删掉的, {跳转到段首，这里便是第一行第一个字符，$P跳到行尾并在前一个字符前粘贴寄存器里内容，即, ZZ保存退出 第四局：14分 &lt;C-V&gt;Mx$P}&lt;C-V&gt;4kx0pZZ 还记得第二局吧，现在我们来优化下 &lt;C-V&gt;Mx进入可视化模式，选中前五行第一个字符并删掉，M代表屏幕中间行 P}&lt;C-V&gt;4kx，P这里直接粘贴,，不用像之前那样还选中再粘贴，}跳到段尾，进入可视化模式，4k像上移动4行，即选中最后五行的最后一列，然后删掉(x) 0pZZ跳到行首，直接p粘贴寄存器里的,，然后保存退出，一共才用14键 这是我能想出来的最少键数了，不过还有更变态的 终极操作：12分 qaxpeq98@aZZ 只有你的击键数足够少才能看到比你更少的，我玩到第四局才看到世界排名第一的操作，他是用录制宏的方式解决的 qa开始录制宏，xp删掉第一个字符(,)，并将其粘贴到后面，e跳到词尾，即跳到刚才粘贴的那个逗号上，然后停止录制，重复98次上述操作 有个更变态的，其实只需要重复94次就可以了 ","link":"https://ixwu.github.io/vimgolf-comma-trouble/"},{"title":"为什么你需要用卡片进行知识管理？","content":"1.卡片用于治学 为什么我们要用卡片进行知识管理，首先看看网上一段文字： 鲁迅写《中国小说史略》，分类摘抄的卡片就有五千多张;姚学垠写《李自成》，阅读大量史籍，摘录卡片有二万多张;明史专家吴晗一生中做的卡片难以计数，其中仅有关《明史》的卡片就有20万张之多。 吴晗甚至这样告诫青年： “一个人要想在学业上有所建树，一定要坚持做卡片笔记，卡片笔记积累多了，功到自然成，通过对大量资料的归纳分类，分析研究和综合利用，就能创造出自己的作品来” 他的卡片治学方法论是这样的： 抄录的内容要有所选择，选取能说明关键性问题的资料，写清楚材料的来源、书名、作者、事件发生的时间等等 凡遇有价值的资料，就抄在卡片上，每张卡片只记一件事、一段话、并且记上出处。日积月累，卡片多了，就按照内容分类保管 等到要研究某个问题时，就把有关该问题的卡片摆出来，加以对照分析，发现问题并进行探讨 钱锺书博览群书，家里藏书却甚少，有的只是数不胜数的读书笔记。据说，中文笔记达1.5万页，外文笔记达3.5万页。 商务印书馆历时15年，于2003年将“日札”结集成3册《钱锺书手稿集·容安馆札记》，于2011年将中文笔记影印成20册《钱锺书手稿集·中文笔记》，于2015年将外文笔记影印成48册《钱锺书手稿集·外文笔记》，外附一册总索引。 钱老文章的一大特色就是喜欢旁征博引，无论古今中外，信手拈来。很多人佩服钱的照相机记忆，杨绛先生在《钱锺书手稿序》中却这样写到： 许多人说，钱锺书记忆力特强，过目不忘。他本人却并不以为自己有那么“神”。他只是好读书，肯下功夫，不仅读，还做笔记；不仅读一遍两遍，还会读三遍四遍，笔记上不断地添补。所以他读的书虽然很多，也不易遗忘……做笔记很费时间。钱钟书做一遍笔记的时间，约莫是读这本书的一倍。他说，一本书，第二遍再读，总会发现读第一遍时会有很多疏忽。最精彩的句子，要读几遍之后才发现。 现在来看看同样喜欢旁征博引的李敖怎样阐释他的读书方法论 我李敖看书很少会忘的原因是我的方法好。什么方法？心狠手辣，看的时候剪刀、美工刀全部出动，把这本书五马分尸。好比这一页或这一段有我需要的资料，我就把它切下来。背面怎么办？背面内容影印出来，或者一开始就买两本书，两本都切开。结果一本书看完了，这本书也被我分尸分掉了。 现在我看书以不影印为原则，因为影印很花时间，基本上我是一开始就买两本，看的时候按照正背面把它切下，虽然比较费钱，可是节省时间。切下来的资料怎么分类呢？我有很多夹子，在上面写上字就表示分类了。好比我写“北京大学”，夹进去的就全部是北京大学的资料。我不断用这种夹子分类，可以分出多少类呢？几千个类来，分得很细很细。一般图书馆的分类，好比哲学类、宗教类、文学类……宗教类又分佛教、道教、天主教等。我李敖分类分得比这个更细，好比“天主教类”还要细分，修女算一类，神父又算一类；神父里的同性恋算一类，还俗的又是一类。好比发生了一个跟修女同性恋有关的新闻，我要发表感想的时候，把这个夹子里的资料一打开，文章立刻写出来！一本书被我大卸八块、五马分尸完，我并不是凭记忆力去记它，而是用很细致的分类方法，很有耐心地把它钩住，放在资料夹里。这样我就把书里面的精华逮到了，这个资料就跑不掉了。——《大卸八块读书法》 2.卡片用于创作 我的偶像纳博科夫后期坚持用卡片进行写作 30年代后期，我开始写《天赋》，也许是需要许多的笔记，我就改用另一种方法，也更实用的方法——用橡皮铅笔在索引卡片上写。因为我向来在一开始就对整部小说有一种奇妙而清晰的前瞻，我发现卡片用起来尤为方便，因为不必按着章节的逻辑顺序，而可以在小说的任何一个部分进行替换，随时填补空白，我恐怕和柏拉图混淆起来，我并不在意他，但我确实认为，就我的情况来说这是真的：整部小说，还没写，就似乎在另外的某个空间完美地准备好了。有时清晰，有时模糊，我的工作就是尽量把我所理解的写出来，尽可能准确地写出来。——《威斯康星研究》（1967） 我现在发现索引卡片真的是进行写作的绝佳纸张，我并不从开头写起，一章接一章地写到结尾。我只是对画面上的空白进行填充，完成我脑海中相当清晰的拼图玩具，这儿取出一块，那儿取出一块，拼出一角天空，再拼出山水景物，再拼出 —— 我不知道,也许是喝得醉醺醺的猎手。——BBC电视台（1962） 我所知道的是，在一部小说写作初期，我很想储备一些稻草、绒毛，衔些小石子；没人知道一只鸟对它未来的巢和巢里的蛋有多清晰的设想，或者鸟压根就不去设想。我写小说从不从头写起，我写第四章前还没写到第三章，我没有义务按顺序从这一页写到下一页；不，我这儿挑一点，那儿挑一点，直到填满纸上全部空白。这就是为什么我喜欢在卡片上写我的短篇小说和长篇小说。当整部作品完成，我稍后再给这些卡片编号。每张卡片改写过多次。大约三张卡片可以打出一页纸。——《花花公子》（1964） 卡夫卡有一篇短篇小说叫《中国长城建造时》（估计是后人加的名字，卡夫卡很多小说是直接从其笔记本里摘来的，有直接翻译为长城的），在我看来，其中谈到的长城建造方法简直就是对写作的隐喻，与纳博科夫遥相呼应。 中国长城是在其最靠北的地方竣工的。此项工程分别由东南和西南开始，最后交汇在这里。在东西两路筑墙大军中，又在更小的范围里实行这种分段修筑的方法，于是修筑城墙的人就被分成一个个二十人左右的小队，每个小队负责修筑出五百米，然后一个相邻的小队再朝他们修筑同样长的一段。可是当这两段连通之后，却并没有接着这一千米的头继续往下修，更确切地说，这两个小队又被派往完全不同的地区去修筑长城。 3.卡片做知识管理的优势 用卡片做知识管理的优点，总结如下： 便携 不知道你有没有突然来了灵感，手头却无纸笔可以记载，只能遗憾地任由其稍纵即逝的尴尬经历。有了卡片，你可以随时随地，掏出几张，抓笔就写。相比较而言，厚重的笔记本简直就是累赘。如今，你可以把手机上的记事本或类似软件，甚至录音app当作卡片的替代品。 简单 面对卡片，你的目标不是写一本书或一篇文章，而是两三句话（相当于一个微博或推特），甚至仅仅是几个关键词。你顿时如释重负，用阳志平的话来说就是降低了认知负荷。 灵活 相比传统手稿而言，卡片更容易调整顺序。你写一张张卡片时，文字已经进行了一定调整，后续连缀成篇时就不需要在字句上做过多修改，而应该聚焦于作品结构，这时，卡片的优势就大大凸显。 王小波说自己写《黄金时代》从二十岁写到四十岁（出自《从&lt;黄金时代&gt;谈小说艺术》），就是在不断调整结构。 有位作家朋友对我说，她很喜欢《情人》那种自由的叙事风格。她以为《情人》是信笔写来的，是自由发挥的结果。我的看法则相反，我认为这篇小说的每一个段落都经过精心的安排......叙事没有按时空的顺序展开，但有另一种逻辑作为线索，这种逻辑我把它叫做艺术——这种写法本身就是种无与伦比的创造。我对这件事很有把握，是因为我也这样写过：把小说的文件调入电脑，反复调动每一个段落，假如原来的小说足够好的话，逐渐就能找到这种线索；花上比写原稿多三到五倍的时间就能得到一篇新小说，比旧的好得没法比。事实上，《情人》也确实是这样改过，一直改到改不动，才交给出版社。——《用一生来学习艺术》 写卡片其实只是初级输入，进阶输入是你要对卡片进行各种处理（编号、修改、分类...），处理得越深入越细致，你才能对知识掌握得越牢靠，输出时才能更加行云流水。背后的原理即“必要难度”，输入越易，输出越难；输入越难，输出越易。 吴晗：对大量资料的归纳分类，分析研究和综合利用 钱锺书：肯下功夫，不仅读，还做笔记；不仅读一遍两遍，还会读三遍四遍，笔记上不断地添补。做一遍笔记的时间，约莫是读这本书的一倍。最精彩的句子，要读几遍之后才发现。 李敖：可以分出多少类呢？几千个类来，分得很细很细。一般图书馆的分类，好比哲学类、宗教类、文学类……宗教类又分佛教、道教、天主教等。我李敖分类分得比这个更细，好比“天主教类”还要细分，修女算一类，神父又算一类；神父里的同性恋算一类，还俗的又是一类。好比发生了一个跟修女同性恋有关的新闻，我要发表感想的时候，把这个夹子里的资料一打开，文章立刻写出来！ ","link":"https://ixwu.github.io/why-do-you-need-cards-to-manage-knownage/"},{"title":"小时读书","content":"李白有诗：小时不识月，呼作白玉盘。初次见月，没有“月”这个概念，故不识，此乃小孩之常情。 相传钱锺书老前辈小时候抓周，抓了一本书，故名锺书。钱老虽是天才，周岁时恐怕也无“书”这个概念，既然“小时不识书”，那么也就不以书为书了，说不定只是当作一种能撕的玩具，“锺书”也就只是“一厢情愿”罢了。后来果真成了一代大学问家，“如愿以偿”，恐怕也只是一种巧合。 说到书的概念，应有广义与狭义之分。从广义上看，世间能看或不能看之物，无不是书。大到宇宙，小到苍蝇，若能参透，其不为学问耶？这是能看之物。再看那不能看的，有善、有恶、有爱、有恨、有道、有德、有仁、有义，若能一一识见，择善而从，其不为美事乎？狭义上的书就不用多说了，我们小时候对书的认识，也多局限于此。钱老家中多笔记而少书，恐怕便与此相关吧。 现在让我回忆第一次读书是什么时候，只能等时间机器发明出来后了。第一次读了什么书，我也回答不上来。从广义上看，最初读到的多是外婆的故事和歌谣，故事我忘得差不多了，歌谣尚记得一首：小棒槌儿，棒田埂儿，姥娘杀鸡我吃腿儿，舅妈杀鸡我喝水儿，表嫂杀鸡没见影儿。这首童谣虽简单，可我也只是长大后才明白其中深意。也罢！也罢！若是从广义上谈我的“小时读书”，恐怕三天三夜也谈不完，还是谈些狭义的吧。 无论做什么事，都得有个机缘，读书也不例外。我最开始是不咋爱看书的，倒是爱听人讲故事，讲完了，再听一个，不讲了，就死缠着人家。故事就这样越来越少，愿意讲的人也越来越少了。我总觉得，在所谓大人的眼里，小孩子是不被当做“人”来看的，因为小孩子有着问不完的问题，而且都与所谓正事无关，故有“惟女子与小人难养也”之说。对我的穷根究底，大人们都不可耐烦，我只好退而求其次——看书！那时看书可没如今这般挑剔，基本有字儿的，我都看。我看过一本破旧的老黄历。看十二生肖，看属羊属马的运势，什么子丑辛未、什么天干地支，把我给搞糊涂了。又看百家姓，“赵钱孙李，周吴郑亡”，听起来跟“赵潜生李，周武阵亡”似的，我曾痴心妄想，想将那几百个姓氏背下，结果“壮志未酬”，只止于前八字。上初中时，问同学借过一本《百家姓》，实在读不下去。 最初所读书，多属漫画一类。比如《葫芦七兄弟》、《金钢葫芦娃》、《金刚葫芦妹》、《机器猫》、《七龙珠》等。也就看图画，明白些简单的意思，多是“为民除害打妖怪，保卫地球斗怪兽”之类的。也看童话，像《格林童话》、《安徒生童话》、《一千零一夜》等。那时有书的人少，有一本就在班里传个遍，等物归原主时，已经是污迹斑斑，缺张少页了。父母很少给我买书，我也只好“书非借不能读也”了。借之外还有换，有一次，为了向一同学借《金刚葫芦娃》（好像是的），我不但把表姐打赏的几毛钱给了他，还把姨妈为我买得《大闹天宫》搭了进去，结果被父母狠训了一顿。 我还看武侠，不过数量较少，读了三四本左右。那时，我放牛，看武侠是为了打发时间。骑在牛背上，牛啃草，忽而抬头远望，我则看着书里的刀光剑影，爱恨情仇，大呼痛快过瘾，恨不能纵身一跃，从此远走天涯，行走江湖。我曾读过一本《独孤求败》，开始以为是金庸的，知道“飞雪连天射白鹿，笑书神侠倚碧鸳”后，才晓得是伪作。不过，直到现在，我也没读完一本金庸武侠，古龙的倒是读的差不多了。 初中时看书，才算是与文学走得近了。第一次买得书是《徐志摩选集》，但我至今也没读完。他的有些诗文，太过抒情，太过肉麻，“浓的化不开”，让人“不忍卒读”。倒是其中一篇与陆小曼合写的剧本，把我感动得不得了，应了那句“久久不能释怀”。那时的最爱当属《三国演义》，真是没日没夜地读，为孔明的神机妙算惊叹不已，为其早逝而扼腕叹息。我读《三国演义》就是读诸葛亮，诸葛亮一死，就兴味阑珊了，跟后来读《红楼梦》就是读林黛玉一样。 既然是小时读书，就举高中以前吧，那时理解的虽不深，却是全凭兴趣，不至于囫囵吞枣，炫耀于人。有一首童谣叫《新年》： 新年来到，糖糕祭灶。 姑娘要花，小子要炮。 老头子要戴新呢帽，老婆子要吃大花糕。 可见不同年龄或不同见识的人是有不同兴趣的，此事不可强求。想一想古代的儿童，一入私塾，就读四书五经，学做八股文，整天摇头晃脑，之乎者也，便不禁心寒。如此一来，生产出来的便多是手无缚鸡之力的书呆子，难怪鲁迅先生要反对读中国书了。 张岱《夜航船》序中记载了这样一件事：昔日有一僧人与一士子同宿夜航船。士子高谈阔论，僧威慑，拳足而寝。僧人听其语有破绽，乃曰：“请问相公，澹台灭明是一个人、两个人？”士子曰：“是两个人。”僧曰：“这等尧舜是一个人、两个人？”士子曰：“自然是一个人！”僧乃笑曰：“这等说来，且待小僧伸伸脚。” 我也亲身经历过类似的事，当时仿宋人作了一则笔记： “昨日在图书馆门口买书，看到一男子指着村上春树的某部作品，对其小伙伴大谈特谈。谈什么，我没听清。他也只是指着书，碰也没碰，末了添了一句：他还得诺贝尔文学奖了！这句我倒是听清了。去年在家坐车，后座为一中年人和一青年人。青年人玩着中年人的手机，那手机大概是塞班系统的，青年人不屑道：‘我要是买手机，绝对不买你这种，你这已经过时了，我要买就买苹果手机，安卓系统比你这牛逼多了！’村上春树怎么想，我不知道，反正乔布斯肯定特想带走他。” 看来我辈当慎读，兴趣之余还要适当了解些常识，“高谈阔论”时当谨遵夫子“不知为不知”之训，“但勿使僧人伸脚则可矣”。 ","link":"https://ixwu.github.io/read-book-in-childhood/"},{"title":"文艺批评与普通读者","content":"周作人的中期散文以其独创的“文抄体”著称，特点是在文章中大段引用他人之文，微评或不表意见。时人讥之为“文抄公”。他在《苦竹杂记.后记》中说：“但是不佞之抄却亦不易，夫天下之书多矣，不能一一抄之，则自然只能选取其一二，又从而录取其一二而已，此乃甚难事也。”晚年给鲍耀明的书信中也提到，“没有意见怎么抄”、“不过我不愿意直说”。此中意味也只有一二友人知之，如钱玄同等。因《五十自寿诗》为人诟骂时，鲁迅在私下对人说：“周作人自寿诗，诚有讽世之意，然此种微辞，已为今之青年所不憭，群公相和，则多近肉麻，于是火上添油，遽成众矢之的。”到底是曾经并肩作战的兄弟。 鲁迅晚年被问到国内最优秀的杂文家都有谁时，也不避嫌地将周作人列为第一，自己居第三。自古文无第一，若论散文成就，列为第一当然也不过分。至于兄弟俩的恩怨，我等外人何必过度关心，每看时人臆测其事，并将猜测当作事实，笔之成文，四处宣传，便恶心不已。如此无耻行径岂非鲁迅所云“空头文学家”，钱锺书曾借《伊索寓言》中蚂蚁与促织的故事讽刺道：生前养不起自己的大作家，到他死后偏有一大批人靠他生活，譬如，写回忆怀念文字的亲戚朋友，写批评论文的批评家和学者。钱老的讽刺往往有些刻薄，但此种情形确是实情。 说到批评家，我就想抄一些知堂老人的话。知堂老人的抄是纵横书海，披沙拣金，我呢，读得书少，只能挑现成的，算是摘抄。他被讥为“文抄公”，我也不等人讥了，直接自嘲为“摘抄生”。然此中亦有“不愿意直说”之“意见”也！ “我以为真的文艺批评，本身便应是一篇文艺，写出著者对于某一作品的印象与鉴赏，决不是偏于理智的论断。现在的批评的缺点大抵就在这一点上。 其一，批评的人以为批评这一个字就是吹求，至少也是含着负的意思，所以文章里必要说些非难轻蔑的话，仿佛是不如此便不成其为批评似的。这些非难文所凭借的无论是旧道德或新文化，但是看错了批评的性质，当然不足取了。 其二，批评的人以为批评是下法律的判决，正如司法官一般；这个判决一下，作品的运命便注定了。在从前主义派别支配文艺界的时代，这样的事确是有过，如约翰孙别林斯奇等便是这一流的贤吏。但在现代这种办法已不通行，这些贤吏的少见那更不必说了。”（《文艺批评杂话》） 国内批评界要么是对某部作品过度吹捧要么就是大肆讨伐，偏于理智的又过分理智，大量专业术语，枯燥乏味，非周作人所谓的“本身便是一篇文艺”也！当然了，我是外行，只是说些作为普通读者的感觉，好的文艺批评定然也存在，只不过在下读书太少，未得见也。 说到普通读者，在下还不够合格，也时常自省。我想，周作人若是知道伍尔芙夫人，定然也喜欢她的那本《普通读者》。 “他读书，是为了自己高兴，而不是为了向别人传授知识，也不是为了纠正别人的看法。首先，他受一种本能所指使，要根据自己能捞到手的一星半点书本知识，塑造出某种整体——某位人物肖像，某个时代略图，某种写作艺术原理。他不停地为自己匆匆搭起某种建筑物，它东倒西歪、摇摇欲坠，然而看来又像是真实的事物，能引人喜爱、欢笑、争论，因此也就能给他带来片刻的满足。他一会儿抓住一首诗，一会儿抓住一本旧书片断，也不管它从哪儿弄来的，也不管它属于何等品类，只求投合自己的心意，能将自己心造的意象结构圆满就成……”（《普通读者.序》） “通常情况下，我们总是以一种模糊和零散的心绪拿起一本书进行阅读，想到的是小说的描写是否逼真，诗歌的情感是否真实，传记的内容是否一味摆好，历史记载是否强化了我们的偏见，等等。如果我们在阅读时能够摆脱这些先入之成见，那么就有了一个良好的开端。不要去指使作者，而要进入作者的世界；尽量成为作者的伙伴和参谋。如果你一开始就退缩一旁，你是你，我是我；或者品头论足，说三道四，你肯定无法从阅读中获得尽可能多的价值。相反，如果你能尽量地敞开心扉，从最初部分开始，那些词语及其隐含之意就会把你带入人类的另一个奇异洞天。深入这个洞天，了解这个洞天，接下来你就会发现作者正在给予或试图给予你的东西是非常明确的、非常实在的。”（《我们应该怎样读书？》） 我不相信这个世界上有什么终极真理，我相信的，套用阿城的书名，即为常识与通识；我也不相信什么乌托邦，我相信这个世界有普世价值。连那句“自由之思想，独立之精神”，我也不大相信了，那是优秀的知识分子追求的，太大，太空，不佞天资鲁钝，只想当个普通读者，了解一些常识就行了。 孔夫子曾说：“己所不欲，勿施于人。”我的毛病恐怕是：己之所欲，欲施于人。世界上没有两片相同的叶子，也没有完全相同的人，故而人的认识也是不同的，但不同的叶子到底是叶子，不同的人同样是人。 所以，我明知道自己的毛病所在，却还是忍不住要说几句。 后记:刚翻日记本，本来想找芥川龙之介《侏儒的话》中讽刺批评家的话，结果却找到了另一段话，大抵可以供给那些以知晓真相自命并大谈周氏兄弟恩怨之流。 “连丑闻也搞不起来的普通人们，从各种各样名士的丑闻中，找到为他们的怯懦辩解的绝妙武器，同时也找到为了树立他们实际上并不存在的优越地位的绝妙基石。” ","link":"https://ixwu.github.io/literary-criticism-and-common-reader/"},{"title":"老井","content":"自从搬到马路边，似乎就再也没有看到井了。我指的是那种年代久远，用青石垒成，布满青苔的古井。 老家就有这样一口井。打我记事起，它就已经存在了。 井不大，周围长着小草，在一条小路旁，一边是农田，一边是小池塘。池塘里的水就近用于灌溉。老家就坐落在池塘边，对面还有一条坝埂，是解放后造的，奶奶说那从前是座老坟山，挖出过不少死人来。坝埂相当于一个小山，将两个湾儿隔开。我们这边是个小湾儿，只有三四户人家。山顶是一条水渠，通往河里。两边种满了松树，到了晚上，黑沉沉的，甚是吓人。 井水很干净，很清冽。 夏天从外面疯闹完回来，嗓子干的冒烟儿，等不及开水摊冷，就直接拿瓢从水缸里舀水喝，还挺甜的。这时，奶奶就训斥我：“嗯（你）奏（就）不晓得等开水摊凉了再喝啊，喝凉水招夫（小心）斗子（肚子）长虫。”我的肚子是确实长过虫的，疼起来的滋味可真不好受，但我常常是好了伤疤忘了疼，喝了甜的发苦的打虫药，把虫屙出来后照样喝凉水。 天气太热时，我就打个挑刮（一丝不挂），跟在爸爸后头，拿着脚盆、水桶，到井边打水冲澡。村人路过，说些玩笑话，我则害羞地用双手遮住下体。 井水不但能喝，能洗澡，还能洗菜，洗衣服。 只有在这些情况下，奶奶才允许我接近水井。她说井里有妖怪，专吃小孩儿。所以，不让我没事就往那边跑。但这更加激起了我的好奇心。我常去井边，看井中我的投影，水桶碰到时就晃荡起来，我想看看是不是真有个青蛙在里面观天，我还期待着飘出个什么怪物，帮我实现不写作业的愿望。 事实上，水里除了蝌蚪、水草、麻癞头（蛤蟆）之外，确实有过一个怪物。 那段时间，井水突然变得浑浊，还发出阵阵臭味儿。水不能喝了，用水得去邻湾儿那口大井挑，两三次也就算了，总去就太历（累）人了。后来，井里漂出一团肉状东西。不知道是什么玩意儿。 二奶皱着眉头，担心道：“会不会是随（谁）家死了娃儿，扔进去了。”要是的话，就太缺德了。 捞了起来发现，原来是一团臭泥巴。扔了后，井水很快就恢复了原来的清澈。 我搬走几年后，井水就不能再喝了。在外求学多年，也没再喝井水了。 ","link":"https://ixwu.github.io/old-well/"},{"title":"打油诗一首","content":"寂寂兮书蠹，至今乎三年。 去日无新伴，来时有旧缘。 既而成萧郎，或可绝尘念。 正是弱冠龄，却为老朽言。 也曾寄时政，佯狂作奇谈。 无关从此弃，代庖不复现。 我本一俗子 ，常想戏人间。 之前多极端，今后归平淡。 ","link":"https://ixwu.github.io/doggerel/"},{"title":"谈装","content":"常感古人造字之形象之会意。 譬如“装”，何义？《说文解字》：装，裹也。此乃本义，后人又引申、衍生无数。 有装束，有装备，有装扮，有装腔作势，有装模作样，有装聋作哑等等。 近来爱读小品文，如张岱之谈山水，周作人之谈思想，汪曾祺之谈吃。爱山水，却踏足不多；爱思想，却所获无几；爱吃，却不甚讲究，皆无从谈起。思来想去，我这人，别的不多，牢骚多矣！索性发一通牢骚，凑一篇小品。 我喜欢拆字游戏，虽说多数解释皆有那么一点牵强附会。比如我名中这个“武”字，“止戈为武”还不是“以暴制暴”。战争是为了带来和平？ 闲话休提，且看“装”字，上为“壮”，下为“衣。”看来，衣是形而下的，壮是形而上的。我们看人，首先看到的便是衣，或曰表象。只因看形而下的靠得是常人皆有之眼，看形而上的却远非肉眼所能及。于是，便有人单从衣着手，穿华丽之服，化媚人之妆，说漂亮之辞，也能欺世盗名，赢得满楼红袖招。何也？我等俗人阅读时由于懒惰或为了掩饰无知，常望文生义，阅人时便也常望“衣”生义。人常说，透过现象看本质。其实，透过现象看到的也还只是现象，望“衣”生义生得也还只是“衣”之义，却误以为是形而上之“壮”。 壮者，强壮也。引申一下，如不可捉摸之所谓内涵，不易验证之所谓智慧。常见所谓成功学大师、国学大师等各种“大湿”招摇过市，媒体热捧，观众膜拜，身后喽啰无数，摇旗呐喊助威。他们也真敢说，“要成功先发疯，头脑简单向前冲”；他们也真敢扯，“国学救国”；他们也真敢吹，“我的成功谁都可以复制”。天花乱坠，鸡血横生。追随者们目眩神迷如沐圣谛，已然进入太虚幻境，飘飘欲仙，不知今夕何夕了。 《逍遥游》：朝菌不知晦朔，蟪蛄不知春秋。小知自大，臧否大知；竖子成名，菲薄英雄。无知者或眼界小见识浅，或急功利求速成，哪识真谛？只能跟着瞎起哄，鹦鹉学舌，焚天灭地，痛哉快哉！以其牛逼之至，不可一世矣！ 这样一来，“壮”又可解释为内心强大，无视一切了。案上泥像，腹中虽空空，若塑金身居大庙，香火能不旺否？ 当然喽，“装”字的发明者有无此意，就不得而知了。我也不过是望人望字生义罢了！ ","link":"https://ixwu.github.io/talk-about-hypocrisy/"},{"title":"碎语闲言","content":"自信爱读书，看了纳博科夫，自卑不已。与之相比，我那只能算吞书，尚未入门，难怪消化不良。 自信懂人性，看了陀思妥耶夫斯基，目瞪口呆。我分析起人性，也说得头头是道；剖析起自我，也够冷血无情。但与之比起来，不过是九牛一毛。人性中还有什么没有被他道出？我得赶紧找找。 自信爱艺术，看了木心，心都凉了。我连何为艺术都不晓得呢！竟奢谈爱艺术。 纳博科夫教我读书， 我说我正在读《包法利夫人》，他问第几遍，我答第一遍，他立马暴跳如雷，第一百遍时才能叫读。可不敢说我还在读《罪与罚》。这个后半生都住在酒店里的俄罗斯汉子丝毫不念民族感情，将陀思妥耶夫斯基骂得狗血淋头，将其作品贬得一文不值。 陀思妥耶夫斯基教我心理学，我惶恐不安，生怕哪一天他突然跪在我面前向我忏悔。 木心给我补课， 我问何为艺术，他答读福楼拜读尼采读陀思妥耶夫斯基。 木心爱写俳句，爱说俏皮话，我附庸风雅，每日也来几句，俳句不够俳句，格言不够格言，俏皮也不够俏皮，姑妄写之，算作碎语闲言。 萨特说，他人即地狱。我眼睛一亮，牢记心间。如今看来，他人有时也是鞭子。 在路上走着，一回头，咦！人呢？ 我所追求的，正是他人唯恐避之不及的。 在一架独木桥上来来回回，终于掉了下去。 起初，读书囫囵吞枣，写作一气呵成，为人吊儿郎当，说话颠三倒四。此为瓶颈。我有句：木心，你劫我见艺术，我知道错了。艺术是霍小玉，我是李益（这是个不要脸的比喻），木心是黄衫客。 我时而狂妄时而自卑，狂妄是因为无知，自卑是因为知道自己无知。 我连怀疑都怀疑。 除了折腾自个儿，我别无所长。 据说，福楼拜说过，包法利夫人就是我。我有句：精神上的包法利夫人一死，福楼拜方才成其为福楼拜。 叔本华有名言：像伟人一样思考，像普通人一样说话。这是教有思想的人应对世俗，或者说教他们谦虚做人。我有句：像上帝一样思考，像魔鬼一样说话。此乃时代嬗变之后果。然后呢？理论就是不实践的意思。 我想把梦写下来，这也是梦。 蒙田论读书，分明就是陶渊明之不求甚解，高则高矣，却如饱读古书的鲁迅让国人莫读古书，我尚有自知之明，赶紧逃到纳博科夫的课堂去挨骂。陶渊明不为五斗米折腰，辞官归隐，蒙田不得已当了市长。我有句：蒙田，法国的大半个陶渊明。 阳台对面有一排不知名的树，枝繁叶茂，郁郁葱葱，雨洗后更是叠青泻翠，绿得晃眼，搜肠刮肚，不能形容。恰读钱锺书之通感论。惊其美，喜其妙。此句油然而起：微风抚枝头，绿叶烧人眼。 钱锺书三个字能让人想到什么？照相机记忆、学问渊博、语言天才、书蠹、文化昆仑。人的劣根性包括只艳羡他人光鲜靓丽的衣服。我有句：所谓天才，不过是有组织有预谋地坚持兴趣的一小撮人。 老子说，天地不仁，以万物为刍狗。这是偏见。天地何曾不仁又何曾仁过，天地非仁也。然而，偏见是对庸见的忍无可忍。 纳博科夫说了，风格和结构是一本小说的精华，伟大的思想不过是一句空洞的废话。这分明是一个伟大的偏见。 我有一个不太高明的句子：概括中心思想是对艺术的强奸。 读书之间的不读书是一种反刍，深思之间的无思亦是。 读博尔赫斯，到结尾，又被骗了。木心说，读个三四遍再去卖弄吧！ 关于引用，畴昔因噎废食，觉得引用是一种偷懒，甚至是一种卖弄。李宗吾读书有三步：以古人为敌，以古人为友，以古人为徒。人之思想皆来自大脑，人之大脑皆有无意识，荣格称之为集体无意识，此乃人思想之根本。所以，所罗门才说太阳底下无新事，柏拉图说一切知识都是回忆。别人说了自己想说的话，完全不必大惊小怪，刻意不引用也全无必要。别人说的没我好，以之为敌，弃之不用；别人说的比我好，以之为友，引用之。 古人不是说，先我注六经，后六经注我。 宇宙观：混沌→有序→混乱 人性观：禽兽→人→禽兽不如 生死观：生不过是死前的一段景象。 自我观：我不过是一个去了势瞎了眼不嬉皮的嬉皮士。 极端地厌恶极端。 唯一一句像俳句的俳句：我思嵇康贤，深林长啸青白眼，风骨不复见。 虚无作如是观。 ","link":"https://ixwu.github.io/my-feeling/"},{"title":"给王二的一封信","content":"亲爱的王二： 想不到分别这么久了，我还会给你写信吧。认识你是一个意外，久别重逢也是一个意外，这封信更是一个意外。就在今天，就在今天，我脱去了我的衣衫，我看到了我皱瘪下垂的乳房，我看到了我干涸无源的沟渠，我想起了我们的伟大友谊，我想起了你。 你是我见过最混蛋又最仗义，最流氓又最善良，最不要脸又最自尊，最不知耻又最单纯的男人。 认识你之前，我并不是破鞋，但人人都说我是破鞋；认识你之后，我变成了破鞋，却再也没有人说我是破鞋。 我不懂，我真的不懂，我不懂这个世界是怎么了；你不懂，你也不懂，不！你是不屑于懂，任何外在世界都影响不了你内心的世界。现在，我懂了，可是我已离不开这世界，离不开这捆绑我的世界，离不开这强奸我的世界。 认识你之前，作为一名医生，我的任务就是：救死扶伤悬壶济世保家卫国；作为一个女人，我的任务就是：生儿育女相夫教子保家卫国；作为一个人，我的任务就是：牺牲自我建设祖国保家卫国。认识你之后，我才知道我之前的世界是多么苍白无力，多么冠冕堂皇，多么枯燥乏味。真的！我乐于当一个破鞋，当一个人人唾弃却自由快乐的破鞋。 还记得吗？ 我们一起探讨我究竟是不是破鞋，我们一起验证我们的伟大友谊，我们一起被批斗写检讨。你受伤时，我哭着对你说：要是你瘫了，我就照顾你一辈子。你第一次掏出你那红彤彤的丑陋玩意儿时，我不受控制地抽了你一耳光；你失踪时，我几乎赤身裸体，只穿着一件空荡荡的白大褂，披星戴月，独自上山寻你…… 伟大友谊不过是一个谎言，这世界也是一个谎言，但我更青睐你所给予的谎言，因为它不攻自破。就因为这个赤裸裸的谎言，我们可以独存天地欺师灭祖无法无天疯狂造爱。 我不知道我们之间算不算爱情，我不知道我们自由而又惊世骇俗的爱有没有令你刻骨铭心，但我知道伟大友谊是不受捆绑不被束缚的，我知道你绝对是这个世界上最王八蛋又最令我难忘的男人。 哎，美好的日子往往极其短暂。文革后，为了生活，我离开了你，有了一个家庭，有了一个女儿。 自从上次偶遇之后，我就再也没有见过你，再也没有了伟大友谊。后来，听说有个叫王小波的作家写了我们的故事。可是，等到我去拜访他时，他已经死了。于是，我错过了这最后一次能够联系到你的机会。这封信，没有邮票，没有地址，只能寄给天地，寄给自由，寄给心中的你。 愿君保重！ 最爱你的陈清扬 ","link":"https://ixwu.github.io/a-letter-to-wang/"}]}